source (en),translation (ko)
"The major changes in this release (for developers currently using the 0.91 release) are a result of merging the 'magic-removal' branch of development. This branch removed a number of constraints in the way Django code had to be written that were a consequence of decisions made in the early days of Django, prior to its open-source release. It's now possible to write more natural, Pythonic code that works as expected, and there's less ""black magic"" happening behind the scenes.","이 릴리스(현재 0.91 릴리스를 사용하는 개발자를 위한)의 주요 변경 사항은 '마법 제거' 개발 브랜치를 병합한 결과입니다. 이 브랜치는 Django의 오픈 소스 릴리스 이전 초기에 내린 결정의 결과인 Django 코드 작성 방식의 여러 제약 조건을 제거했습니다. 이제 예상대로 작동하는 보다 자연스러운 Python 코드를 작성할 수 있으며, 배후에서 발생하는 ""흑마법""이 줄어듭니다."
"Aside from that, another main theme of this release is a dramatic increase in usability. We've made countless improvements in error messages, documentation, etc., to improve developers' quality of life.","그 외에도, 이번 릴리스의 또 다른 주요 테마는 사용 편의성의 극적인 증가입니다. 우리는 개발자의 삶의 질을 향상시키기 위해 오류 메시지, 문서 등에서 수 많은 개선을 했습니다."
The new features and changes introduced in 0.95 include:,0.95에 도입된 새로운 기능과 변경 사항은 다음과 같습니다:
Django now uses a more consistent and natural filtering interface for retrieving objects from the database.,Django는 이제 데이터베이스에서 개체를 검색하기 위해 보다 일관되고 자연스러운 필터링 인터페이스를 사용합니다.
"User-defined models, functions and constants now appear in the module namespace they were defined in. (Previously everything was magically transferred to the ``django.models.*`` namespace.)","사용자 정의 모델, 함수 및 상수는 이제 정의된 모듈 네임스페이스에 나타납니다. (이전에는 모든 것이 마술처럼 ``django.models.*`` 네임스페이스로 전송되었습니다.)"
"Some optional applications, such as the FlatPage, Sites and Redirects apps, have been decoupled and moved into ``django.contrib``. If you don't want to use these applications, you no longer have to install their database tables.","FlatPage, Sites 및 Redirects 앱과 같은 일부 선택적 애플리케이션은 분리되어 ``django.contrib``로 이동되었습니다. 이러한 응용 프로그램을 사용하지 않으려면 더 이상 해당 데이터베이스 테이블을 설치할 필요가 없습니다."
Django now has support for managing database transactions.,Django는 이제 데이터베이스 트랜잭션 관리를 지원합니다.
"We've added the ability to write custom authentication and authorization backends for authenticating users against alternate systems, such as LDAP.",LDAP와 같은 대체 시스템에 대해 사용자를 인증하기 위해 사용자 지정 인증 및 승인 백엔드를 작성하는 기능을 추가했습니다.
"We've made it easier to add custom table-level functions to models, through a new ""Manager"" API.","새로운 ""관리자"" API를 통해 모델에 사용자 지정 테이블 수준의 기능들을 더 쉽게 추가할 수 있습니다."
"It's now possible to use Django without a database. This simply means that the framework no longer requires you to have a working database set up just to serve dynamic pages. In other words, you can just use URLconfs/views on their own. Previously, the framework required that a database be configured, regardless of whether you actually used it.","이제 데이터베이스 없이 Django를 사용할 수 있습니다. 이는 프레임워크가 더 이상 동적 페이지를 제공하기 위해 작업 데이터베이스를 설정할 필요가 없음을 의미합니다. 즉, URLconfs/views를 자체적으로 사용할 수 있습니다. 이전에는 실제로 데이터베이스를 사용했는지 여부에 관계없이 프레임워크에서 데이터베이스를 구성해야 했습니다."
"It's now more explicit and natural to override ``save()`` and ``delete()`` methods on models, rather than needing to hook into the ``pre_save()`` and ``post_save()`` method hooks.","이제 ``pre_save()`` 및 ``post_save()`` 메서드 후크에 연결할 필요 없이, 모델에서 ``save()`` 및 ``delete()`` 메서드를 더 명확하고 자연스럽게 재정의할 수 있습니다."
"Individual pieces of the framework now can be configured without requiring the setting of an environment variable. This permits use of, for example, the Django templating system inside other applications.","이제 환경 변수를 설정하지 않고도 프레임워크의 개별 부분을 구성할 수 있습니다. 이를 통해, 예를 들어, 다른 애플리케이션 내에서 Django 템플릿 시스템을 사용할 수 있습니다."
"More and more parts of the framework have been internationalized, as we've expanded internationalization (i18n) support. The Django codebase, including code and templates, has now been translated, at least in part, into 31 languages. From Arabic to Chinese to Hungarian to Welsh, it is now possible to use Django's admin site in your native language.","국제화(i18n) 지원을 확장함에 따라, 프레임워크의 더 많은 부분이 국제화되었습니다. 코드와 템플릿을 포함한 Django 코드베이스는 이제 적어도 부분적으로는 31개 언어로 번역되었습니다. 아랍어에서 중국어, 헝가리어, 웨일스어에 이르기까지 이제 Django의 관리 사이트를 모국어로 사용할 수 있습니다."
"The number of changes required to port from 0.91-compatible code to the 0.95 code base are significant in some cases. However, they are, for the most part, reasonably routine and only need to be done once. A list of the necessary changes is described in the `Removing The Magic`_ wiki page. There is also an easy checklist_ for reference when undertaking the porting operation.",경우에 따라 0.91 호환 코드에서 0.95 코드 베이스로 포팅하는 데 필요한 변경 사항의 수가 중요합니다. 그러나 대부분의 변경들은 합리적으로 일상적이며 한 번만 수행하면 됩니다. 필요한 변경 목록은 `Removing The Magic`_ 위키 페이지에 설명되어 있습니다. 포팅 작업을 수행할 때 참조할 수 있는 쉬운 체크리스트_도 있습니다.
Problem reports and getting help,문제 보고 및 도움 받기
"Need help resolving a problem with Django? The documentation in the distribution is also available :doc:`online </index>` at the `Django website`_. The :doc:`FAQ </faq/index>` document is especially recommended, as it contains a number of issues that come up time and again.",Django의 문제를 해결하는 데 도움이 필요하십니까? 배포판에 있는 문서는 `Django 웹사이트`_에 있는 :doc:`온라인 </index>`에서도 볼 수 있습니다. :doc:`FAQ </faq/index>` 문서에는 자주 제기되는 여러 가지 문제가 포함되어 있기 때문에 특히 권장됩니다.
"For more personalized help, the `django-users`_ mailing list is a very active list, with more than 2,000 subscribers who can help you solve any sort of Django problem. We recommend you search the archives first, though, because many common questions appear with some regularity, and any particular problem may already have been answered.","보다 개인화된 도움이 필요한 경우 `django-users`_ 메일링 리스트는 Django 문제를 해결하는 데 도움을 줄 수 있는 2,000명 이상의 구독자가 있는 매우 활동적인 목록입니다. 그러나 많은 일반적인 질문이 어느 정도 규칙적으로 나타나며 특정 문제에 대한 답변이 이미 있을 수 있으므로 아카이브를 먼저 검색하는 것이 좋습니다."
"Finally, for those who prefer the more immediate feedback offered by IRC, there's a ``#django`` channel on ``irc.libera.chat`` that is regularly populated by Django users and developers from around the world. Friendly people are usually available at any hour of the day -- to help, or just to chat.","마지막으로, IRC가 제공하는 보다 즉각적인 피드백을 선호하는 사람들을 위해, 전 세계의 Django 사용자 및 개발자가 자주 확인하는 ``irc.libera.chat``의 ``#django`` 채널이 있습니다. 친절한 사람들은 일반적으로 하루 중 언제라도 도움을 주거나 채팅을 할 수 있습니다."
Thanks for using Django!,장고를 이용해 주셔서 감사합니다!
The Django Team July 2006,The Django Team July 2006
Django version 0.96 release notes,Django 버전 0.96 릴리스 정보
Welcome to Django 0.96!,Django 0.96에 오신 것을 환영합니다!
"The primary goal for 0.96 is a cleanup and stabilization of the features introduced in 0.95. There have been a few small `backwards-incompatible changes`_ since 0.95, but the upgrade process should be fairly simple and should not require major changes to existing applications.","0.96의 주요 목표는 0.95에 도입된 기능을 정리하고 안정화하는 것입니다. 0.95 이후 몇 가지 작은 '역호환되지 않는 변경들'_이 있었지만, 업그레이드 프로세스는 상당히 단순해야 하며 기존 애플리케이션에 큰 변경이 필요하지 않아야 합니다."
"However, we're also releasing 0.96 now because we have a set of backwards-incompatible changes scheduled for the near future. Once completed, they will involve some code changes for application developers, so we recommend that you stick with Django 0.96 until the next official release; then you'll be able to upgrade in one step instead of needing to make incremental changes to keep up with the development version of Django.","그러나 지금 0.96를 릴리스 하는 이유는 가까운 장래에 이전 버전과 호환되지 않는 일련의 변경이 예정되어 있기 때문입니다. 이 변경에는 애플리케이션 개발자를 위한 일부 코드 변경이 포함되므로, 다음 공식 릴리스까지 Django 0.96을 사용하는 것을 권장합니다. 그러면 Django의 개발 버전을 따라잡기 위해 점진적인 변경을 수행할 필요 없이 한 번에 업그레이드할 수 있습니다."
Backwards-incompatible changes,이전 버전과 호환되지 않는 변경
The following changes may require you to update your code when you switch from 0.95 to 0.96:,다음 변경 사항으로 인해 0.95에서 0.96으로 전환할 때 코드를 업데이트해야 할 수 있습니다.
``MySQLdb`` version requirement,``MySQLdb`` 버전 요구 사항
"Due to a bug in older versions of the ``MySQLdb`` Python module (which Django uses to connect to MySQL databases), Django's MySQL backend now requires version 1.2.1p2 or higher of ``MySQLdb``, and will raise exceptions if you attempt to use an older version.","이전 버전의 ``MySQLdb`` Python 모듈(Django가 MySQL 데이터베이스에 연결하는 데 사용함)의 버그로 인해 Django의 MySQL 백엔드는 이제 ``MySQLdb`` 버전 1.2.1p2 이상이 필요하며, 이전 버전을 사용하려고 하면 예외가 발생합니다."
"If you're currently unable to upgrade your copy of ``MySQLdb`` to meet this requirement, a separate, backwards-compatible backend, called ""mysql_old"", has been added to Django. To use this backend, change the ``DATABASE_ENGINE`` setting in your Django settings file from this::","현재 이 요구 사항을 충족하기 위해 ``MySQLdb`` 사본을 업그레이드할 수 없는 경우, ""mysql_old""라는 별도의 이전 버전과 호환되는 백엔드가 Django에 추가되었습니다. 이 백엔드를 사용하려면 다음에서 Django 설정 파일의 ``DATABASE_ENGINE`` 설정을 변경하십시오::"
to this::,이에::
"However, we strongly encourage MySQL users to upgrade to a more recent version of ``MySQLdb`` as soon as possible, The ""mysql_old"" backend is provided only to ease this transition, and is considered deprecated; aside from any necessary security fixes, it will not be actively maintained, and it will be removed in a future release of Django.","그러나 우리는 MySQL 사용자가 가능한 한 빨리 ``MySQLdb``의 최신 버전으로 업그레이드할 것을 강력히 권장합니다. ""mysql_old"" 백엔드는 이러한 전환을 용이하게 하기 위해서만 제공되며, 이후에는 더 이상 사용되지 않는 것으로 간주됩니다. 필요한 보안 수정 사항을 제외하고는 적극적으로 유지 관리되지 않으며, Django의 향후 릴리스에서 제거될 예정입니다."
"Also, note that some features, like the new ``DATABASE_OPTIONS`` setting (see the :doc:`databases documentation </ref/databases>` for details), are only available on the ""mysql"" backend, and will not be made available for ""mysql_old"".","또한 새로운 ``DATABASE_OPTIONS`` 설정(자세한 내용은 :doc:`데이터베이스 문서 </ref/databases>` 참조)과 같은 일부 기능은 ""mysql"" 백엔드에서만 사용할 수 있으며, ""mysql_old""에서는 사용할 수 없습니다. ."
Database constraint names changed,데이터베이스 제약 조건 이름 변경
"The format of the constraint names Django generates for foreign key references have changed slightly. These names are generally only used when it is not possible to put the reference directly on the affected column, so they are not always visible.","Django가 외래 키 참조를 위해 생성하는 제약 조건 이름의 형식이 약간 변경되었습니다. 이러한 이름은 일반적으로 영향을 받는 열에 참조를 직접 배치할 수 없는 경우에만 사용되므로, 항상 표시되는 것은 아닙니다."
"The effect of this change is that running ``manage.py reset`` and similar commands against an existing database may generate SQL with the new form of constraint name, while the database itself contains constraints named in the old form; this will cause the database server to raise an error message about modifying nonexistent constraints.","이 변경의 효과는 기존 데이터베이스에 대해 ``manage.py reset`` 및 유사한 명령을 실행하면 새로운 형식의 제약 조건 이름으로 SQL을 생성할 수 있지만, 데이터베이스 자체에는 이전 형식으로 명명된 제약 조건이 포함된다는 것입니다. 이로 인해 데이터베이스 서버는 존재하지 않는 제약 조건 수정에 대한 오류 메시지를 발생시킵니다."
"If you need to work around this, there are two methods available:","이 문제를 해결해야 하는 경우, 다음 두 가지 방법을 사용할 수 있습니다:"
"Redirect the output of ``manage.py`` to a file, and edit the generated SQL to use the correct constraint names before executing it.","``manage.py``의 출력을 파일로 리디렉션하고, 실행하기 전에 올바른 제약 조건 이름을 사용하도록 생성된 SQL을 편집합니다."
"Examine the output of ``manage.py sqlall`` to see the new-style constraint names, and use that as a guide to rename existing constraints in your database.","``manage.py sqlall``의 출력을 검사하여 새로운 스타일의 제약 조건 이름을 확인하고, 이를 가이드로 사용하여 데이터베이스의 기존 제약 조건 이름을 바꾸십시오."
Name changes in ``manage.py``,``manage.py``의 이름 변경
A few of the options to ``manage.py`` have changed with the addition of fixture support:,``manage.py``에 대한 몇 가지 옵션이 픽스처 지원 추가로 변경되었습니다.
"There are new ``dumpdata`` and ``loaddata`` commands which, as you might expect, will dump and load data to/from the database. These commands can operate against any of Django's supported serialization formats.","새로운 ``dumpdata`` 및 ``loaddata`` 명령이 있으며, 이는 예상할 수 있듯이 데이터베이스로/에서 데이터를 덤프하고 로드합니다. 이러한 명령은 Django에서 지원하는 모든 직렬화 형식에 대해 작동할 수 있습니다."
"The ``sqlinitialdata`` command has been renamed to ``sqlcustom`` to emphasize that ``loaddata`` should be used for data (and ``sqlcustom`` for other custom SQL -- views, stored procedures, etc.).","``loaddata``가 데이터 (및 다른 사용자 지정 SQL (뷰, 저장 프로시저 등)을 위한 ``sqlcustom``)에 사용되어야 함을 강조하기 위해 ``sqlinitialdata`` 명령이 ``sqlcustom``으로 이름이 변경되었습니다. "
The vestigial ``install`` command has been removed. Use ``syncdb``.,사용되지 않는 ``install`` 명령이 제거되었습니다. ``syncdb``를 사용하십시오.
Backslash escaping changed,백슬래시 이스케이프 변경
"The Django database API now escapes backslashes given as query parameters. If you have any database API code that matches backslashes, and it was working before (despite the lack of escaping), you'll have to change your code to ""unescape"" the slashes one level.","Django 데이터베이스 API는 이제 쿼리 매개변수로 제공된 백슬래시를 이스케이프 처리합니다. 백슬래시와 일치하는 데이터베이스 API 코드가 있고, (이스케이프가 없음에도 불구하고) 이전에 작동하고 있었다면, 슬래시를 한 단계 ""이스케이프 해제""하도록 코드를 변경해야 합니다."
"For example, this used to work::","예를 들어, 이는 다음과 같이 작동했습니다::"
"The above is now incorrect, and should be rewritten as::","위의 내용은 이제 올바르지 않으며, 다음과 같이 다시 작성해야 합니다::"
Removed ENABLE_PSYCO setting,ENABLE_PSYCO 설정 제거
"The ``ENABLE_PSYCO`` setting no longer exists. If your settings file includes ``ENABLE_PSYCO`` it will have no effect; to use Psyco_, we recommend writing a middleware class to activate it.",``ENABLE_PSYCO`` 설정은 더 이상 존재하지 않습니다. 설정 파일에 ``ENABLE_PSYCO``가 포함되어 있으면 아무런 효과가 없습니다. Psyco_를 사용하려면 미들웨어 클래스를 작성하여 활성화하는 것이 좋습니다.
What's new in 0.96?,0.96의 새로운 기능은 무엇입니까?
"This revision represents over a thousand source commits and over four hundred bug fixes, so we can't possibly catalog all the changes. Here, we describe the most notable changes in this release.","이 개정판은 1000개 이상의 소스 커밋과 400개 이상의 버그 수정을 나타내므로, 모든 변경 사항을 카탈로그화할 수는 없습니다. 여기에서는 이 릴리스에서 가장 눈에 띄는 변경 사항을 설명합니다."
New forms library,새 양식 라이브러리
"``django.newforms`` is Django's new form-handling library. It's a replacement for ``django.forms``, the old form/manipulator/validation framework.  Both APIs are available in 0.96, but over the next two releases we plan to switch completely to the new forms system, and deprecate and remove the old system.","``django.newforms``는 Django의 새로운 폼 처리 라이브러리입니다. 이전 양식/조작자/검증 프레임워크인 ``django.forms``를 대체합니다. 두 API 모두 0.96에서 사용할 수 있지만 다음 두 릴리스에서 새로운 양식 시스템으로 완전히 전환하고, 이전 시스템을 더 이상 사용하지 않고 제거할 계획입니다."
There are three elements to this transition:,이 전환에는 세 가지 요소가 있습니다:
We've copied the current ``django.forms`` to ``django.oldforms``. This allows you to upgrade your code *now* rather than waiting for the backwards-incompatible change and rushing to fix your code after the fact.  Just change your import statements like this::,현재 ``django.forms``를 ``django.oldforms``에 복사했습니다. 이렇게 하면 이전 버전과 호환되지 않는 변경을 기다리거나 사후에 코드를 수정하기 위해 서두르지 않고 *지금* 코드를 업그레이드할 수 있습니다. import 문을 다음과 같이 변경하십시오::
"The next official release of Django will move the current ``django.newforms`` to ``django.forms``. This will be a backwards-incompatible change, and anyone still using the old version of ``django.forms`` at that time will need to change their import statements as described above.",Django의 다음 공식 릴리스는 현재 ``django.newforms``를 ``django.forms``로 옮길 것입니다. 이는 이전 버전과 호환되지 않는 변경 사항이며 당시 ``django.forms``의 이전 버전을 사용하는 사람은 위에서 설명한 대로 import 문을 변경해야 합니다.
The next release after that will completely remove ``django.oldforms``.,그 다음 릴리스에서는 ``django.oldforms``가 완전히 제거됩니다.
"Although the ``newforms`` library will continue to evolve, it's ready for use for most common cases. We recommend that anyone new to form handling skip the old forms system and start with the new.","``newforms`` 라이브러리는 계속 발전하겠지만, 대부분의 일반적인 경우에는 사용할 준비가 되어 있습니다. 양식 처리를 처음 접하는 사람은 이전 양식 시스템을 건너뛰고 새 양식으로 시작하는 것이 좋습니다."
"For more information about ``django.newforms``, read the :doc:`newforms documentation </topics/forms/index>`.",``django.newforms``에 대한 자세한 내용은 :doc:`newforms 문서 </topics/forms/index>`를 참조하세요.
URLconf improvements,URLconf 개선
"You can now use any callable as the callback in URLconfs (previously, only strings that referred to callables were allowed). This allows a much more natural use of URLconfs. For example, this URLconf::","이제 URLconf에서 콜백으로 모든 콜러블을 사용할 수 있습니다(이전에는 콜러블을 참조하는 문자열만 허용됨). 이를 통해 URLconf를 훨씬 더 자연스럽게 사용할 수 있습니다. 예를 들어, 이 URLconf::"
can now be rewritten as::,이제 다음과 같이 다시 작성할 수 있습니다::
"One useful application of this can be seen when using decorators; this change allows you to apply decorators to views *in your URLconf*. Thus, you can make a generic view require login very easily::",데코레이터를 사용할 때 유용한 응용 프로그램 중 하나를 볼 수 있습니다. 이 변경으로 *URLconf*의 뷰에 데코레이터를 적용할 수 있습니다. 따라서 로그인이 필요한 일반 뷰를 매우 쉽게 만들 수 있습니다::
"Note that both syntaxes (strings and callables) are valid, and will continue to be valid for the foreseeable future.","두 구문(문자열 및 콜러블)이 모두 유효하며, 가까운 미래에도 계속 유효할 것이라는 점에 유의하십시오."
The test framework,테스트 프레임워크
Django now includes a test framework so you can start transmuting fear into boredom (with apologies to Kent Beck). You can write tests based on :mod:`doctest` or :mod:`unittest` and test your views with a simple test client.,Django에는 이제 테스트 프레임워크가 포함되어 있으므로 두려움을 지루함으로 바꿀 수 있습니다. :mod:`doctest` 또는 :mod:`unittest`를 기반으로 테스트를 작성하고 간단한 테스트 클라이언트로 뷰를 테스트할 수 있습니다.
"There is also new support for ""fixtures"" -- initial data, stored in any of the supported :doc:`serialization formats </topics/serialization>`, that will be loaded into your database at the start of your tests. This makes testing with real data much easier.","""픽스처""에 대한 새로운 지원도 있습니다. 즉, 테스트 시작 시 데이터베이스에 로드될 지원되는 :doc:`직렬화 형식 </topics/serialization>` 중 하나로 저장된 초기 데이터입니다. 이렇게 하면 실제 데이터로 훨씬 쉽게 테스트할 수 있습니다."
See :doc:`the testing documentation </topics/testing/index>` for the full details.,자세한 내용은 :doc:`테스트 문서 </topics/testing/index>`를 참조하세요.
Improvements to the admin interface,관리 인터페이스 개선
"A small change, but a very nice one: dedicated views for adding and updating users have been added to the admin interface, so you no longer need to worry about working with hashed passwords in the admin.","약간의 변경 사항이지만 매우 훌륭합니다: 사용자 추가 및 업데이트를 위한 전용 보기가 관리자 인터페이스에 추가되었으므로, 더 이상 관리자에서 해시된 암호 작업에 대해 걱정할 필요가 없습니다."
Thanks,감사합니다
"Since 0.95, a number of people have stepped forward and taken a major new role in Django's development. We'd like to thank these people for all their hard work:",0.95 이후로 많은 사람들이 Django 개발에 있어 중요한 역할을 맡았습니다. 다음 분들의 노고에 감사드립니다:
Russell Keith-Magee and Malcolm Tredinnick for their major code contributions. This release wouldn't have been possible without them.,Russell Keith-Magee와 Malcolm Tredinnick의 주요 코드 기여. 이 릴리스는 그들 없이는 가능하지 않았을 것입니다.
"Our new release manager, James Bennett, for his work in getting out 0.95.1, 0.96, and (hopefully) future release.","0.95.1, 0.96 및 (바라건대) 향후 릴리스를 내놓는 작업에 대한 새로운 릴리스 관리자인 James Bennett에게 감사드립니다."
"Our ticket managers Chris Beaven (aka SmileyChris), Simon Greenhill, Michael Radziej, and Gary Wilson. They agreed to take on the monumental task of wrangling our tickets into nicely cataloged submission. Figuring out what to work on is now about a million times easier; thanks again, guys.","티켓 매니저 Chris Beaven(일명 SmileyChris), Simon Greenhill, Michael Radziej, Gary Wilson. 그들은 우리의 티켓을 멋지게 분류하여 제출하는 기념비적인 일을 맡는 데 동의했습니다. 작업할 내용을 파악하는 것이 이제 백만 배 더 쉬워졌습니다. 다시 한 번 감사드립니다."
"Everyone who submitted a bug report, patch or ticket comment. We can't possibly thank everyone by name -- over 200 developers submitted patches that went into 0.96 -- but everyone who's contributed to Django is listed in :source:`AUTHORS`.","버그 보고서, 패치 또는 티켓 댓글을 제출한 모든 사람. 200명 이상의 개발자가 0.96에 적용된 패치를 제출했습니다. 하지만 Django에 기여한 모든 사람은 :source:`AUTHORS`에 나열되어 있습니다."
Django 1.0 release notes,Django 1.0 릴리스 노트
Welcome to Django 1.0!,Django 1.0에 오신 것을 환영합니다!
"We've been looking forward to this moment for over three years, and it's finally here. Django 1.0 represents the largest milestone in Django's development to date: a web framework that a group of perfectionists can truly be proud of.",우리는 3년 넘게 이 순간을 고대해 왔습니다. Django 1.0은 현재까지 Django 개발에서 가장 큰 이정표를 나타냅니다: 완벽주의자 그룹이 진정으로 자랑스러워할 수 있는 웹 프레임워크입니다.
"Django 1.0 represents over three years of community development as an Open Source project. Django's received contributions from hundreds of developers, been translated into fifty languages, and today is used by developers on every continent and in every kind of job.","Django 1.0은 오픈 소스 프로젝트로서 3년 이상 동안 커뮤니티에서 개발되었습니다. Django는 수백 명의 개발자로부터 기여를 받았으며, 50개 언어로 번역되었고, 오늘날 모든 대륙의 개발자들이 모든 종류의 직업에서 사용하고 있습니다."
"An interesting historical note: when Django was first released in July 2005, the initial released version of Django came from an internal repository at revision number 8825. Django 1.0 represents revision 8961 of our public repository. It seems fitting that our 1.0 release comes at the moment where community contributions overtake those made privately.","흥미로운 역사 기록: Django가 2005년 7월에 처음 출시되었을 때, Django의 초기 출시 버전은 개정 번호 8825의 내부 저장소에서 나왔습니다. Django 1.0은 공개 저장소의 개정 8961을 나타냅니다. 우리의 1.0 릴리스는 커뮤니티 기여가 비공개 기여를 능가하는 순간에 릴리스하는 것이 적절해 보입니다."
Stability and forwards-compatibility,안정성 및 상위 호환성
"The release of Django 1.0 comes with a promise of API stability and forwards-compatibility. In a nutshell, this means that code you develop against Django 1.0 will continue to work against 1.1 unchanged, and you should need to make only minor changes for any 1.X release.","Django 1.0의 출시는 API 안정성과 상위 호환성을 약속합니다. 간단히 말해서 이것은 Django 1.0에 대해 개발한 코드가 변경되지 않은 1.1에 대해 계속 작동하며, 모든 1.X 릴리스에 대해 사소한 변경만 수행해야 함을 의미합니다."
See the :doc:`API stability guide </misc/api-stability>` for full details.,자세한 내용은 :doc:`API 안정성 가이드 </misc/api-stability>`을 참조하세요.
"Django 1.0 has a number of backwards-incompatible changes from Django 0.96. If you have apps written against Django 0.96 that you need to port, see our detailed porting guide:",Django 1.0에는 Django 0.96에서 이전 버전과 호환되지 않는 여러 변경 사항이 있습니다. 이식해야 하는 Django 0.96 앱이 있는 경우 자세한 이식 가이드를 참조하세요:
A complete list of backwards-incompatible changes can be found at https://code.djangoproject.com/wiki/BackwardsIncompatibleChanges.,이전 버전과 호환되지 않는 변경 사항의 전체 목록은 https://code.djangoproject.com/wiki/BackwardsIncompatibleChanges에서 찾을 수 있습니다.
"The documentation has been greatly improved, cleaned up, and generally made awesome. There's now dedicated search, indexes, and more.","문서화가 크게 개선되고 정리되었으며 일반적으로 훌륭해졌습니다. 이제 전용 검색, 인덱스 등이 있습니다."
"We can't possibly document everything that's new in 1.0, but the documentation will be your definitive guide. Anywhere you see something like:","1.0의 새로운 기능을 모두 문서화할 수는 없지만, 문서화는 당신의 최종 가이드가 되어줄 것입니다. 어디에서나 다음과 같은 것을 볼 수 있습니다:"
You'll know that you're looking at something new or changed.,새로운 것이나 변경된 것을 보고 있다는 것을 알게 될 것입니다.
The other major highlights of Django 1.0 are:,Django 1.0의 다른 주요 특징은 다음과 같습니다:
Refactored admin application,리팩터링된 관리자 애플리케이션
"The Django administrative interface (``django.contrib.admin``) has been completely refactored; admin definitions are now completely decoupled from model definitions (no more ``class Admin`` declaration in models!), rewritten to use Django's new form-handling library (introduced in the 0.96 release as ``django.newforms``, and now available as simply ``django.forms``) and redesigned with extensibility and customization in mind. Full documentation for the admin application is available online in the official Django documentation:","Django 관리 인터페이스(``django.contrib.admin``)가 완전히 리팩토링되었습니다. admin 정의는 이제 모델 정의에서 완전히 분리되었으며(더 이상 ``class Admin``을 모델에서 선언 할 필요가 없습니다!) Django의 새로운 양식 처리 라이브러리(0.96 릴리스에서 ``django.newforms``로 도입되었고, 이젠 간단히 ``django.forms``로 사용 가능)를 사용하도록 재작성되었으며, 확장성과 사용자 정의를 염두에 두고 재설계되었습니다. 관리 애플리케이션에 대한 전체 문서는 공식 Django 문서에서 온라인으로 제공됩니다:"
See the :doc:`admin reference </ref/contrib/admin/index>` for details,자세한 내용은 :doc:`admin reference </ref/contrib/admin/index>`을 참조하십시오.
Improved Unicode handling,향상된 유니코드 처리
"Django's internals have been refactored to use Unicode throughout; this drastically simplifies the task of dealing with non-Western-European content and data in Django. Additionally, utility functions have been provided to ease interoperability with third-party libraries and systems which may or may not handle Unicode gracefully. Details are available in Django's Unicode-handling documentation.",Django의 내부는 전체적으로 유니코드를 사용하도록 리팩터링되었습니다. 이는 Django에서 비서유럽 콘텐츠 및 데이터를 처리하는 작업을 대폭 단순화합니다. 또한 유니코드를 정상적으로 처리하거나 처리하지 않을 수 있는 타사 라이브러리 및 시스템과의 상호 운용성을 용이하게 하기 위해 유틸리티 기능이 제공되었습니다. 자세한 내용은 Django의 유니코드 처리 문서에서 확인할 수 있습니다.
See :doc:`/ref/unicode`.,:doc:`/ref/unicode`를 참조하십시오.
An improved ORM,개선된 ORM
"Django's object-relational mapper -- the component which provides the mapping between Django model classes and your database, and which mediates your database queries -- has been dramatically improved by a massive refactoring. For most users of Django this is backwards-compatible; the public-facing API for database querying underwent a few minor changes, but most of the updates took place in the ORM's internals. A guide to the changes, including backwards-incompatible modifications and mentions of new features opened up by this refactoring, is `available on the Django wiki`__.",Django의 개체 관계형 매퍼(Django 모델 클래스와 데이터베이스 사이의 매핑을 제공하고 데이터베이스 쿼리를 중재하는 구성 요소)는 대규모 리팩토링을 통해 크게 향상되었습니다. 대부분의 Django 사용자에게 이는 이전 버전과 호환됩니다. 데이터베이스 쿼리를 위한 공용 API는 약간의 변경이 있었지만 대부분의 업데이트는 ORM의 내부에서 이루어졌습니다. 이전 버전과 호환되지 않는 수정 및 이 리팩토링으로 추가된 새로운 기능에 대한 언급을 포함한 변경 사항에 대한 가이드는 `Django wiki에서 볼 수 있습니다`__.
Automatic escaping of template variables,템플릿 변수의 자동 이스케이프
"To provide improved security against cross-site scripting (XSS) vulnerabilities, Django's template system now automatically escapes the output of variables. This behavior is configurable, and allows both variables and larger template constructs to be marked as safe (requiring no escaping) or unsafe (requiring escaping). A full guide to this feature is in the documentation for the :ttag:`autoescape` tag.","XSS(교차 사이트 스크립팅) 취약성에 대해 향상된 보안을 제공하기 위해, Django의 템플릿 시스템은 이제 자동으로 변수 출력을 이스케이프 처리합니다. 이 동작은 변경 가능하며, 변수와 더 큰 템플릿 구성을 모두 안전(이스케이프 필요 없음) 또는 안전하지 않음(이스케이프 필요)으로 표시할 수 있습니다. 이 기능에 대한 전체 가이드는 :ttag:`autoescape` 태그에 대한 문서에 있습니다."
``django.contrib.gis`` (GeoDjango),``django.contrib.gis`` (GeoDjango)
"A project over a year in the making, this adds world-class GIS (`Geographic Information Systems`_) support to Django, in the form of a ``contrib`` application. Its documentation is currently being maintained externally, and will be merged into the main Django documentation shortly. Huge thanks go to Justin Bronn, Jeremy Dunck, Brett Hoerner and Travis Pinney for their efforts in creating and completing this feature.","1년 넘게 진행 중인 이 프로젝트는 ``contrib`` 애플리케이션의 형태로 Django에 세계적 수준의 GIS(`Geographic Information Systems`_) 지원을 추가합니다. 해당 문서는 현재 외부에서 유지 관리되고 있으며, 곧 기본 Django 문서에 병합될 예정입니다. 이 기능을 만들고 완성하기 위해 노력한 Justin Bronn, Jeremy Dunck, Brett Hoerner 및 Travis Pinney에게 큰 감사를 드립니다."
See :doc:`GeoDjango </ref/contrib/gis/index>` for details.,자세한 내용은 :doc:`GeoDjango </ref/contrib/gis/index>`을 참조하세요.
Pluggable file storage,플러그형 파일 스토리지
"Django's built-in ``FileField`` and ``ImageField`` now can take advantage of pluggable file-storage backends, allowing extensive customization of where and how uploaded files get stored by Django. For details, see :doc:`the files documentation </topics/files>`; big thanks go to Marty Alchin for putting in the hard work to get this completed.","Django의 내장 ``FileField`` 및 ``ImageField``는 이제 플러그형 파일 스토리지 백엔드를 활용할 수 있으므로, 업로드된 파일이 Django에 의해 저장되는 위치와 방법을 광범위하게 사용자 정의할 수 있습니다. 자세한 내용은 :doc:`the files documentation </topics/files>`을 참조하십시오. 이 작업을 완료하기 위해 열심히 노력한 Marty Alchin에게 큰 감사를 드립니다."
Jython compatibility,Jython 호환성
"Thanks to a lot of work from Leo Soto during a Google Summer of Code project, Django's codebase has been refactored to remove incompatibilities with `Jython`_, an implementation of Python written in Java, which runs Python code on the Java Virtual Machine. Django is now compatible with the forthcoming Jython 2.5 release.","Google Summer of Code 프로젝트 동안, Leo Soto의 많은 작업 덕분에 Django의 코드베이스가 리팩터링되어 Java Virtual Machine에서 Python 코드를 실행하는 Java로 작성된 Python 구현인 `Jython`_과의 비호환성을 제거했습니다. Django는 이제 곧 출시될 Jython 2.5 릴리스와 호환됩니다."
Generic relations in forms and admin,양식 및 관리자의 일반적인 관계
Classes are now included in ``django.contrib.contenttypes`` which can be used to support generic relations in both the admin interface and in end-user forms. See :ref:`the documentation for generic relations <generic-relations>` for details.,클래스는 이제 ``django.contrib.contenttypes``에 포함되어 관리자 인터페이스와 최종 사용자 양식 모두에서 일반 관계를 지원하는 데 사용할 수 있습니다. 자세한 내용은 :ref:`제네릭 관계 <generic-relations> 문서`를 참조하십시오.
``INSERT``/``UPDATE`` distinction,``INSERT``/``UPDATE`` 구분
"Although Django's default behavior of having a model's ``save()`` method automatically determine whether to perform an ``INSERT`` or an ``UPDATE`` at the SQL level is suitable for the majority of cases, there are occasional situations where forcing one or the other is useful. As a result, models can now support an additional parameter to ``save()`` which can force a specific operation.","모델의 ``save()`` 메서드가 SQL 수준에서 ``INSERT``을 수행할 것인지 ``UPDATE``를 수행할 것인지를 자동으로 결정하는 Django의 기본값 동작은 대부분의 경우에 적합하지만, 가끔 둘 중 하나를 강제하는 것이 유용할 때가 있습니다. 결과적으로, 이제 모델은 특정 작업을 강제할 수 있는 ``save()``에 대한 추가 매개변수를 지원할 수 있습니다."
See :ref:`ref-models-force-insert` for details.,자세한 내용은 :ref:`ref-models-force-insert`를 참조하십시오.
Split ``CacheMiddleware``,``CacheMiddleware`` 분할
"Django's ``CacheMiddleware`` has been split into three classes: ``CacheMiddleware`` itself still exists and retains all of its previous functionality, but it is now built from two separate middleware classes which handle the two parts of caching (inserting into and reading from the cache) separately, offering additional flexibility for situations where combining these functions into a single middleware posed problems.",Django의 ``CacheMiddleware``는 세 가지 클래스로 분할되었습니다. ``CacheMiddleware`` 자체는 여전히 존재하며 이전 기능을 모두 유지합니다. 그러나 이제는 캐싱의 두 부분(캐시에 삽입 및 읽기)을 개별적으로 처리하는 두 개의 개별 미들웨어 클래스에서 빌드됩니다. 이러한 기능을 하나의 미들웨어로 결합하면 문제가 발생하는 상황에 대해 추가적인 유연성을 제공합니다.
"Full details, including updated notes on appropriate use, are in :doc:`the caching documentation </topics/cache>`.",적절한 사용에 대한 업데이트된 참고 사항을 포함한 전체 세부 정보는 :doc:`the caching documentation </topics/cache>`에 있습니다.
Refactored ``django.contrib.comments``,리팩터된 ``django.contrib.comments``
"As part of a Google Summer of Code project, Thejaswi Puthraya carried out a major rewrite and refactoring of Django's bundled comment system, greatly increasing its flexibility and customizability.","Google Summer of Code 프로젝트의 일환으로, Thejaswi Puthraya는 Django의 번들 주석 시스템을 대대적으로 재작성하고 리팩토링하여 유연성과 사용자 정의 가능성을 크게 높였습니다."
Removal of deprecated features,더 이상 사용되지 않는 기능 제거
"A number of features and methods which had previously been marked as deprecated, and which were scheduled for removal prior to the 1.0 release, are no longer present in Django. These include imports of the form library from ``django.newforms`` (now located simply at ``django.forms``), the ``form_for_model`` and ``form_for_instance`` helper functions (which have been replaced by ``ModelForm``) and a number of deprecated features which were replaced by the dispatcher, file-uploading and file-storage refactoring introduced in the Django 1.0 alpha releases.","이전에 '더 이상 사용되지 않는 것'으로 표시되고, 1.0 릴리스 이전에 제거될 예정이었던 많은 기능과 메서드가 Django에서 제거되었습니다. 여기에는 ``django.newforms``(현재 ``django.forms``에 위치)에서 양식 라이브러리 가져오기, ``form_for_model`` 및 ``form_for_instance`` 헬퍼 함수(``ModelForm``으로 대체됨), 디스패처로 대체된 여러 가지 사용되지 않는 기능들 및 Django 1.0 알파 릴리스에 도입된 파일 업로드 및 파일 저장 리팩토링이 포함됩니다."
Known issues,알려진 문제들
"We've done our best to make Django 1.0 as solid as possible, but unfortunately there are a couple of issues that we know about in the release.","우리는 Django 1.0을 가능한 한 견고하게 만들기 위해 최선을 다했지만, 안타깝게도 릴리스에서 몇 가지 알려진 문제가 있습니다."
Multi-table model inheritance with ``to_field``,``to_field``를 사용한 다중 테이블 모델 상속
"If you're using :ref:`multiple table model inheritance <multi-table-inheritance>`, be aware of this caveat: child models using a custom ``parent_link`` and ``to_field`` will cause database integrity errors. A set of models like the following are **not valid**::",":ref:`다중 테이블 모델 상속 <multi-table-inheritance>'을 사용하는 경우, 다음을 주의하십시오: 사용자 지정 ``parent_link`` 및 ``to_field``를 사용하는 자식 모델은 데이터베이스 무결성 오류를 일으킵니다. 다음과 같은 모델 집합은 **유효하지 않습니다**::"
This bug will be fixed in the next release of Django.,이 버그는 Django의 다음 릴리스에서 수정될 것입니다.
Caveats with support of certain databases,특정 데이터베이스 지원에 대한 주의 사항
"Django attempts to support as many features as possible on all database backends. However, not all database backends are alike, and in particular many of the supported database differ greatly from version to version. It's a good idea to checkout our :doc:`notes on supported database </ref/databases>`:","Django는 모든 데이터베이스 백엔드에서 가능한 한 많은 기능을 지원하려고 합니다. 그러나 모든 데이터베이스 백엔드가 동일한 것은 아니며, 특히 지원되는 많은 데이터베이스가 버전마다 크게 다릅니다. :doc:`지원되는 데이터베이스에 대한 참고 사항 </ref/databases>`을 확인하는 것이 좋습니다:"
:ref:`mysql-notes`,:ref:`mysql-notes`
:ref:`sqlite-notes`,:ref:`sqlite-notes`
:ref:`oracle-notes`,:ref:`oracle-notes`
Porting your apps from Django 0.96 to 1.0,Django 0.96에서 1.0으로 앱 포팅
Django 1.0 breaks compatibility with 0.96 in some areas.,Django 1.0은 일부 영역에서 0.96과 호환되지 않습니다.
"This guide will help you port 0.96 projects and apps to 1.0. The first part of this document includes the common changes needed to run with 1.0. If after going through the first part your code still breaks, check the section `Less-common Changes`_ for a list of a bunch of less-common compatibility issues.","이 가이드는 0.96 프로젝트 및 앱을 1.0으로 포팅하는 것을 알려드립니다. 이 문서의 첫 번째 부분에는 1.0에서 실행하는 데 필요한 일반적인 변경 사항이 포함되어 있습니다. 첫 번째 부분을 진행한 후에도 코드가 여전히 깨지면, `덜 일반적인 변경 사항`_ 섹션에서 덜 일반적인 호환성 문제 목록을 확인하세요."
The :doc:`1.0 release notes </releases/1.0>`. That document explains the new features in 1.0 more deeply; the porting guide is more concerned with helping you quickly update your code.,:doc:`1.0 릴리스 노트 </releases/1.0>`. 이 문서는 1.0의 새로운 기능을 더 자세히 설명합니다. 포팅 가이드는 코드를 빠르게 업데이트하는 데 더 많은 관심이 있습니다.
Common changes,일반적인 변경 사항
This section describes the changes between 0.96 and 1.0 that most users will need to make.,이 섹션에서는 대부분의 사용자가 수행해야 하는 0.96과 1.0 사이의 변경 사항에 대해 설명합니다.
Use Unicode,유니코드 사용
"Change string literals (``'foo'``) into Unicode literals (``u'foo'``). Django now uses Unicode strings throughout. In most places, raw strings will continue to work, but updating to use Unicode literals will prevent some obscure problems.","문자열 리터럴(``'foo'``)을 유니코드 리터럴(``u'foo'``)로 변경합니다. Django는 이제 전체적으로 유니코드 문자열을 사용합니다. 대부분의 경우, 원시 문자열은 계속 작동하지만 유니코드 리터럴을 사용하도록 업데이트하면 모호한 문제를 방지할 수 있습니다."
See :doc:`/ref/unicode` for full details.,자세한 내용은 :doc:`/ref/unicode`를 참조하십시오.
Common changes to your models file:,모델 파일에 대한 일반적인 변경 사항:
Rename ``maxlength`` to ``max_length``,``maxlength``를 ``max_length``로 이름 바꾸기
Rename your ``maxlength`` argument to ``max_length`` (this was changed to be consistent with form fields):,``maxlength`` 인수의 이름을 ``max_length``로 바꾸십시오(양식 필드와 일치하도록 변경됨):
Replace ``__str__`` with ``__unicode__``,``__str__``을 ``__unicode__``로 교체
"Replace your model's ``__str__`` function with a ``__unicode__`` method, and make sure you `use Unicode`_ (``u'foo'``) in that method.","모델의 ``__str__`` 함수를 ``__unicode__`` 메서드로 바꾸고, 해당 메서드에서 `유니코드를 사용`_(``u'foo'``)하고 있는지 확인하세요."
Remove ``prepopulated_from``,``prepopulated_from`` 제거
"Remove the ``prepopulated_from`` argument on model fields. It's no longer valid and has been moved to the ``ModelAdmin`` class in ``admin.py``. See `the admin`_, below, for more details about changes to the admin.","모델 필드에서 ``prepopulated_from`` 인수를 제거하십시오. 이는 더 이상 유효하지 않으며, ``admin.py``의 ``ModelAdmin`` 클래스로 이동되었습니다. 관리자 변경에 대한 자세한 내용은 아래의 `관리자`_를 참조하십시오."
Remove ``core``,``코어`` 제거
"Remove the ``core`` argument from your model fields. It is no longer necessary, since the equivalent functionality (part of :ref:`inline editing <admin-inlines>`) is handled differently by the admin interface now. You don't have to worry about inline editing until you get to `the admin`_ section, below. For now, remove all references to ``core``.",모델 필드에서 ``core`` 인수를 제거하십시오. 이는 동등한 기능(:ref:'인라인 편집 <admin-inlines>'의 일부)이 이제 관리자 인터페이스에서 다르게 처리되기 때문에 더 이상 필요하지 않습니다. 아래의 `관리자`_ 섹션에 도달할 때까지 인라인 편집에 대해 걱정할 필요가 없습니다. 지금은 ``core``에 대한 모든 참조를 제거합니다.
Replace ``class Admin:`` with ``admin.py``,``class Admin:``을 ``admin.py``로 바꾸십시오.
"Remove all your inner ``class Admin`` declarations from your models. They won't break anything if you leave them, but they also won't do anything. To register apps with the admin you'll move those declarations to an ``admin.py`` file; see `the admin`_ below for more details.","모델에서 모든 내부 ``class Admin`` 선언을 제거하십시오. 제거하지 않으면 문제가 되는 것은 아니지만, 아무 역할도 하지 않을 것입니다. 관리자에게 앱을 등록하려면 해당 선언을 ``admin.py`` 파일로 이동해야 합니다. 자세한 내용은 아래의 `관리자`_를 참조하십시오."
A contributor to djangosnippets__ has written a script that'll `scan your models.py and generate a corresponding admin.py`__.,djangosnippets__의 기여자는 `models.py를 스캔하고 해당 admin.py를 생성하는`__ 스크립트를 작성했습니다.
Example,예제
Below is an example ``models.py`` file with all the changes you'll need to make:,다음은 필요한 모든 변경 사항이 포함된 ``models.py`` 파일의 예입니다:
Old (0.96) ``models.py``::,오래된 (0.96) ``models.py``::
New (1.0) ``models.py``::,신규 (1.0) ``models.py``::
New (1.0) ``admin.py``::,신규 (1.0) ``admin.py``::
The Admin,관리자
"One of the biggest changes in 1.0 is the new admin. The Django administrative interface (``django.contrib.admin``) has been completely refactored; admin definitions are now completely decoupled from model definitions, the framework has been rewritten to use Django's new form-handling library and redesigned with extensibility and customization in mind.","1.0의 가장 큰 변화 중 하나는 새로운 관리자입니다. Django 관리 인터페이스(``django.contrib.admin``)가 완전히 리팩토링되었습니다. 관리자 정의는 이제 모델 정의에서 완전히 분리되었으며, 프레임워크는 Django의 새로운 양식 처리 라이브러리를 사용하도록 재작성되었으며, 확장성과 사용자 지정을 염두에 두고 재설계되었습니다."
"Practically, this means you'll need to rewrite all of your ``class Admin`` declarations. You've already seen in `models`_ above how to replace your ``class Admin`` with an ``admin.site.register()`` call in an ``admin.py`` file. Below are some more details on how to rewrite that ``Admin`` declaration into the new syntax.","실질적으로, 이는 모든 ``class Admin`` 선언을 다시 작성해야 함을 의미합니다. 위의 `models`_에서 ``admin.py`` 파일에서 ``class Admin``을 ``admin.site.register()`` 호출로 대체하는 방법을 이미 보았습니다. 다음은 ``Admin`` 선언을 새 구문으로 다시 작성하는 방법에 대한 자세한 내용입니다."
Use new inline syntax,새로운 인라인 구문 사용
The new ``edit_inline`` options have all been moved to ``admin.py``. Here's an example:,새로운 ``edit_inline`` 옵션이 모두 ``admin.py``로 이동되었습니다. 예를 들면 다음과 같습니다:
Old (0.96)::,이전 (0.96)::
New (1.0)::,신규 (1.0)::
See :ref:`admin-inlines` for more details.,자세한 내용은 :ref:`admin-inlines`을 참조하십시오.
"Simplify ``fields``, or use ``fieldsets``",``fields`` 단순화 또는 ``fieldsets`` 사용
"The old ``fields`` syntax was quite confusing, and has been simplified. The old syntax still works, but you'll need to use ``fieldsets`` instead.","이전 ``fields`` 구문은 매우 혼란스러웠기 때문에 단순화되었습니다. 이전 구문은 여전히 작동하지만, 대신 ``fieldsets``를 사용해야 합니다."
More detailed information about the changes and the reasons behind them can be found on the `NewformsAdminBranch wiki page`__,변경 사항 및 그 이유에 대한 자세한 정보는 `NewformsAdminBranch 위키 페이지`__에서 찾을 수 있습니다.
The new admin comes with a ton of new features; you can read about them in the :doc:`admin documentation </ref/contrib/admin/index>`.,새로운 관리자에게는 수많은 새로운 기능이 제공됩니다. :doc:`admin 문서 </ref/contrib/admin/index>`에서 이에 대해 읽을 수 있습니다.
Update your root ``urls.py``,루트 ``urls.py`` 업데이트
"If you're using the admin site, you need to update your root ``urls.py``.","관리 사이트를 사용하는 경우, 루트 ``urls.py``를 업데이트해야 합니다."
Old (0.96) ``urls.py``::,이전(0.96) ``urls.py``::
New (1.0) ``urls.py``::,신규 (1.0) ``urls.py``::
Use ``django.forms`` instead of ``newforms``,``newforms`` 대신 ``django.forms`` 사용
Replace ``django.newforms`` with ``django.forms`` -- Django 1.0 renamed the ``newforms`` module (introduced in 0.96) to plain old ``forms``. The ``oldforms`` module was also removed.,``django.newforms``를 ``django.forms``로 바꾸십시오 -- Django 1.0은 ``newforms`` 모듈(0.96에 도입됨)을 일반 이전 ``forms``로 이름을 바꿨습니다. ``oldforms`` 모듈도 제거되었습니다.
"If you're already using the ``newforms`` library, and you used our recommended ``import`` statement syntax, all you have to do is change your import statements.","이미 ``newforms`` 라이브러리를 사용 중이고, 권장하는 ``import`` 문 구문을 사용했다면, import 문을 변경하기만 하면 됩니다."
Old::,이전::
New::,신규::
"If you're using the old forms system (formerly known as ``django.forms`` and ``django.oldforms``), you'll have to rewrite your forms. A good place to start is the :doc:`forms documentation </topics/forms/index>`","이전 양식 시스템(이전의 ``django.forms`` 및 ``django.oldforms``)을 사용하는 경우, 양식을 다시 작성해야 합니다. :doc:`양식 문서 </topics/forms/index>`을 통해 시작하는 것이 좋습니다."
Handle uploaded files using the new API,새로운 API를 사용하여 업로드된 파일 처리
"Replace use of uploaded files -- that is, entries in ``request.FILES`` -- as simple dictionaries with the new :class:`~django.core.files.uploadedfile.UploadedFile`. The old dictionary syntax no longer works.","업로드된 파일(즉, ``request.FILES`` 항목)의 사용을 새로운 :class:`~django.core.files.uploadedfile.UploadedFile`로 간단한 사전으로 대체하십시오. 이전 사전 구문은 더 이상 작동하지 않습니다."
"Thus, in a view like::","따라서, 다음과 같은 뷰에서::"
...you'd need to make the following changes:,...다음과 같이 변경해야 합니다:
Old (0.96),이전 (0.96)
New (1.0),신규 (1.0)
``f['content']``,``f['content']``
``f.read()``,``f.read()``
``f['filename']``,``f['filename']``
``f.name``,``f.name``
``f['content-type']``,``f['content-type']``
``f.content_type``,``f.content_type``
Work with file fields using the new API,새 API를 사용하여 파일 필드 작업
"The internal implementation of :class:`django.db.models.FileField` have changed. A visible result of this is that the way you access special attributes (URL, filename, image size, etc.) of these model fields has changed. You will need to make the following changes, assuming your model's :class:`~django.db.models.FileField` is called ``myfile``:",":class:`django.db.models.FileField`의 내부 구현이 변경되었습니다. 모델 필드의 특수 속성(URL, 파일 이름, 이미지 크기 등)에 액세스하는 방식이 변경되었습니다. 모델의 :class:`~django.db.models.FileField`가 ``myfile``이라고 가정하고 다음과 같이 변경해야 합니다:"
``myfile.get_content_filename()``,``myfile.get_content_filename()``
``myfile.content.path``,``myfile.content.path``
``myfile.get_content_url()``,``myfile.get_content_url()``
``myfile.content.url``,``myfile.content.url``
``myfile.get_content_size()``,``myfile.get_content_size()``
``myfile.content.size``,``myfile.content.size``
``myfile.save_content_file()``,``myfile.save_content_file()``
``myfile.content.save()``,``myfile.content.save()``
``myfile.get_content_width()``,``myfile.get_content_width()``
``myfile.content.width``,``myfile.content.width``
``myfile.get_content_height()``,``myfile.get_content_height()``
``myfile.content.height``,``myfile.content.height``
Note that the ``width`` and ``height`` attributes only make sense for :class:`~django.db.models.ImageField` fields. More details can be found in the :doc:`model API </ref/models/fields>` documentation.,``width`` 및 ``height`` 속성은 :class:`~django.db.models.ImageField` 필드에만 의미가 있습니다. 자세한 내용은 :doc:`model API </ref/models/fields>` 문서에서 찾을 수 있습니다.
Use ``Paginator`` instead of ``ObjectPaginator``,``ObjectPaginator`` 대신 ``Paginator`` 사용
"The ``ObjectPaginator`` in 0.96 has been removed and replaced with an improved version, :class:`django.core.paginator.Paginator`.","0.96의 ``ObjectPaginator``가 제거되고, 개선된 버전인 :class:`django.core.paginator.Paginator`로 대체되었습니다."
Learn to love autoescaping,자동 이스케이핑을 사랑하는 법 배우기
"By default, the template system now automatically HTML-escapes the output of every variable. To learn more, see :ref:`automatic-html-escaping`.","기본적으로, 템플릿 시스템은 이제 모든 변수의 출력을 자동으로 HTML 이스케이프 처리합니다. 자세한 내용은 :ref:`automatic-html-escaping`을 참조하십시오."
"To disable auto-escaping for an individual variable, use the :tfilter:`safe` filter:",개별 변수에 대한 자동 이스케이프를 비활성화하려면 :tfilter:`safe` 필터를 사용하세요:
"To disable auto-escaping for an entire template, wrap the template (or just a particular section of the template) in the :ttag:`autoescape` tag:","전체 템플릿에 대해 자동 이스케이프를 비활성화하려면, 템플릿(또는 템플릿의 특정 섹션)을 :ttag:`autoescape` 태그로 래핑합니다:"
Less-common changes,일반적이지 않은 변경 사항
"The following changes are smaller, more localized changes. They should only affect more advanced users, but it's probably worth reading through the list and checking your code for these things.","다음 변경 사항은 더 작고 지역화된 변경 사항입니다. 고급 사용자에게만 영향을 주지만, 목록을 읽고 이러한 사항에 대한 코드를 확인하는 것이 좋습니다."
Signals,시그널
Add ``**kwargs`` to any registered signal handlers.,등록된 시그널 처리기에 ``**kwargs``를 추가하십시오.
"Connect, disconnect, and send signals via methods on the :class:`~django.dispatch.Signal` object instead of through module methods in ``django.dispatch.dispatcher``.","``django.dispatch.dispatcher``의 모듈 메서드 대신 :class:`~django.dispatch.Signal` 객체의 메서드를 통해 신호를 연결, 연결 해제 및 전송합니다."
Remove any use of the ``Anonymous`` and ``Any`` sender options; they no longer exist. You can still receive signals sent by any sender by using ``sender=None``,``Anonymous`` 및 ``Any`` 발신자 옵션 사용을 제거하십시오. 그들은 더 이상 존재하지 않습니다. ``sender=None``을 사용하여 모든 보낸 사람이 보낸 신호를 계속 받을 수 있습니다.
Make any custom signals you've declared into instances of :class:`django.dispatch.Signal` instead of anonymous objects.,익명 객체 대신 :class:`django.dispatch.Signal` 인스턴스로 선언한 사용자 지정 시그널을 만듭니다.
Here's quick summary of the code changes you'll need to make:,다음은 수행해야 하는 코드 변경에 대한 간략한 요약입니다:
``def callback(sender)``,``def callback(sender)``
"``def callback(sender, **kwargs)``","``def callback(sender, **kwargs)``"
``sig = object()``,``sig = object()``
``sig = django.dispatch.Signal()``,``sig = django.dispatch.Signal()``
"``dispatcher.connect(callback, sig)``","``dispatcher.connect(callback, sig)``"
``sig.connect(callback)``,``sig.connect(callback)``
"``dispatcher.send(sig, sender)``","``dispatcher.send(sig, sender)``"
``sig.send(sender)``,``sig.send(sender)``
"``dispatcher.connect(callback, sig, sender=Any)``","``dispatcher.connect(callback, sig, sender=Any)``"
"``sig.connect(callback, sender=None)``","``sig.connect(callback, sender=None)``"
"If you were using Django 0.96's ``django.contrib.comments`` app, you'll need to upgrade to the new comments app introduced in 1.0. See the upgrade guide for details.","Django 0.96의 ``django.contrib.comments`` 앱을 사용하고 있었다면, 1.0에 도입된 새로운 코멘트 앱으로 업그레이드해야 합니다. 자세한 내용은 업그레이드 가이드를 참조하세요."
:ttag:`spaceless` tag,:ttag:`spaceless` 태그
"The ``spaceless`` template tag now removes *all* spaces between HTML tags, instead of preserving a single space.","``spaceless`` 템플릿 태그는 이제 단일 공백을 유지하는 대신, HTML 태그 사이의 *모든* 공백을 제거합니다."
Local flavors,지역 풍미
U.S. local flavor,U.S. 지역 풍미
"``django.contrib.localflavor.usa`` has been renamed to ``django.contrib.localflavor.us``. This change was made to match the naming scheme of other local flavors. To migrate your code, all you need to do is change the imports.","``django.contrib.localflavor.usa``는 ``django.contrib.localflavor.us``로 이름이 변경되었습니다. 이 변경은 다른 지역 풍미의 명명 체계와 일치하도록 만들어졌습니다. 코드를 마이그레이션하려면, import를 변경하기만 하면 됩니다."
Getting a new session key,새 세션 키 얻기
``SessionBase.get_new_session_key()`` has been renamed to ``_get_new_session_key()``. ``get_new_session_object()`` no longer exists.,``SessionBase.get_new_session_key()``는 ``_get_new_session_key()``로 이름이 변경되었습니다. ``get_new_session_object()``는 더 이상 존재하지 않습니다.
Fixtures,픽스처
Loading a row no longer calls ``save()``,행을 로드할 때 더 이상 ``save()``를 호출하지 않습니다.
"Previously, loading a row automatically ran the model's ``save()`` method. This is no longer the case, so any fields (for example: timestamps) that were auto-populated by a ``save()`` now need explicit values in any fixture.","이전에는 행을 로드하면 모델의 ``save()`` 메서드가 자동으로 실행되었습니다. 이제는 실행되지 않으므로, ``save()``에 의해 자동으로 채워진 모든 필드(예: 타임스탬프)는 이제 모든 픽스처에 명시적인 값이 필요합니다."
Better exceptions,더 나은 예외
The old :exc:`EnvironmentError` has split into an :exc:`ImportError` when Django fails to find the settings module and a :exc:`RuntimeError` when you try to reconfigure settings after having already used them.,"이전 :exc:`EnvironmentError`는 :exc:`ImportError` (Django가 설정 모듈을 찾는 데 실패할 때)와, :exc:`RuntimeError` (이미 사용한 후에 설정을 재구성하려고 할 때)로 분할되었습니다."
:setting:`LOGIN_URL` has moved,:setting:`LOGIN_URL`이 이동됨
The :setting:`LOGIN_URL` constant moved from ``django.contrib.auth`` into the ``settings`` module. Instead of using ``from django.contrib.auth import LOGIN_URL`` refer to :setting:`settings.LOGIN_URL <LOGIN_URL>`.,:setting:`LOGIN_URL` 상수가 ``django.contrib.auth``에서 ``settings`` 모듈로 이동했습니다. ``from django.contrib.auth import LOGIN_URL``을 사용하는 대신 :setting:`settings.LOGIN_URL <LOGIN_URL>`을 참조하십시오.
:setting:`APPEND_SLASH` behavior has been updated,:setting:`APPEND_SLASH` 동작이 업데이트되었습니다.
"In 0.96, if a URL didn't end in a slash or have a period in the final component of its path, and :setting:`APPEND_SLASH` was True, Django would redirect to the same URL, but with a slash appended to the end. Now, Django checks to see whether the pattern without the trailing slash would be matched by something in your URL patterns. If so, no redirection takes place, because it is assumed you deliberately wanted to catch that pattern.","0.96에서 URL이 슬래시로 끝나지 않거나, 경로의 마지막 구성 요소에 마침표가 있고 :setting:`APPEND_SLASH`가 True인 경우 Django는 동일한 URL로 리디렉션되지만 끝에 슬래시가 추가됩니다. 이제 Django는 후행 슬래시가 없는 패턴이 URL 패턴의 무언가와 일치하는지 확인합니다. 만약 일치한다면 의도적으로 해당 패턴을 포착하려 했다고 가정하고 리디렉션이 발생하지 않습니다."
"For most people, this won't require any changes. Some people, though, have URL patterns that look like this::","대부분의 경우, 아무런 변경이 필요하지 않습니다. 그러나 어떤 사람들은 다음과 같은 URL 패턴을 가지고 있습니다::"
"Previously, those patterns would have been redirected to have a trailing slash. If you always want a slash on such URLs, rewrite the pattern as::","이전에는 이러한 패턴이 후행 슬래시를 갖도록 리디렉션되었습니다. 이러한 URL에 항상 슬래시를 사용하고 싶다면, 패턴을 다음과 같이 다시 작성하세요::"
Smaller model changes,더 작은 모델 변경
Different exception from ``get()``,``get()``과 다른 예외
Managers now return a :exc:`~django.core.exceptions.MultipleObjectsReturned` exception instead of :exc:`AssertionError`:,매니저는 이제 :exc:`AssertionError` 대신 :exc:`~django.core.exceptions.MultipleObjectsReturned` 예외를  리턴합니다.
``LazyDate`` has been fired,``LazyDate``가 제거됨
The ``LazyDate`` helper class no longer exists.,``LazyDate`` 헬퍼 클래스는 더 이상 존재하지 않습니다.
"Default field values and query arguments can both be callable objects, so instances of ``LazyDate`` can be replaced with a reference to ``datetime.datetime.now``:","기본 필드 값과 쿼리 인수는 모두 콜러블 객체가 될 수 있으므로, ``LazyDate`` 인스턴스를 ``datetime.datetime.now``에 대한 레퍼런스로 대체할 수 있습니다:"
"``DecimalField`` is new, and ``FloatField`` is now a proper float","``DecimalField``는 새로운 기능이며, ``FloatField``이 이제 적절한 float입니다."
"If you forget to make this change, you will see errors about ``FloatField`` not taking a ``max_digits`` attribute in ``__init__``, because the new ``FloatField`` takes no precision-related arguments.","이 변경을 잊어버리면, ``FloatField``가 ``__init__``에서 ``max_digits`` 속성을 사용하지 않는다는 오류가 표시됩니다. 왜냐하면 새로운 ``FloatField``는 정밀도 관련 인수를 사용하지 않기 때문입니다."
"If you're using MySQL or PostgreSQL, no further changes are needed. The database column types for ``DecimalField`` are the same as for the old ``FloatField``.","MySQL 또는 PostgreSQL을 사용하는 경우, 아무런 추가 변경이 필요하지 않습니다. ``DecimalField``에 대한 데이터베이스 열 유형은 이전 ``FloatField``와 동일합니다."
"If you're using SQLite, you need to force the database to view the appropriate columns as decimal types, rather than floats. To do this, you'll need to reload your data. Do this after you have made the change to using ``DecimalField`` in your code and updated the Django code.","SQLite를 사용하는 경우, 데이터베이스에서 적절한 열을 부동 소수점이 아닌 십진수 유형으로 다루도록 강제해야 합니다. 이렇게 하려면 데이터를 다시 로드해야 합니다. 코드에서 ``DecimalField``를 사용하도록 변경하고, Django 코드를 업데이트한 후에 이 작업을 수행하십시오."
**Back up your database first!**,**먼저 데이터베이스를 백업하세요!**
"For SQLite, this means making a copy of the single file that stores the database (the name of that file is the ``DATABASE_NAME`` in your ``settings.py`` file).","SQLite의 경우, 이는 데이터베이스를 저장하는 단일 파일의 복사본을 만드는 것을 의미합니다(해당 파일의 이름은 ``settings.py`` 파일의 ``DATABASE_NAME``입니다)."
"To upgrade each application to use a ``DecimalField``, you can do the following, replacing ``<app>`` in the code below with each app's name:","``DecimalField``를 사용하도록 각 애플리케이션을 업그레이드하려면, 아래 코드에서 ``<app>``을 각 앱의 이름으로 대체하여 다음을 수행할 수 있습니다:"
It's important that you remember to use XML format in the first step of this process. We are exploiting a feature of the XML data dumps that makes porting floats to decimals with SQLite possible.,이 프로세스의 첫 번째 단계에서 XML 형식을 사용하는 것을 기억하는 것이 중요합니다. 우리는 SQLite를 사용하여 부동 소수점을 십진법으로 이식할 수 있는 XML 데이터 덤프의 기능을 이용하고 있습니다.
In the second step you will be asked to confirm that you are prepared to lose the data for the application(s) in question. Say yes; we'll restore this data in the third step.,두 번째 단계에서는 해당 응용 프로그램의 데이터를 잃을 준비가 되었는지 확인하라는 메시지가 표시됩니다. '네'라고 대답하십시오; 세 번째 단계에서 이 데이터를 복원할 것입니다.
"``DecimalField`` is not used in any of the apps shipped with Django prior to this change being made, so you do not need to worry about performing this procedure for any of the standard Django models.","``DecimalField``는 이 변경 이전에 Django와 함께 제공되는 앱에서는 일절 사용되지 않으므로, 표준 Django 모델에 대해 이 절차를 수행하는 것에 대해 걱정할 필요가 없습니다."
"If something goes wrong in the above process, just copy your backed up database file over the original file and start again.","위의 과정에서 문제가 발생하면, 백업된 데이터베이스 파일을 원본 파일에 복사하고 다시 시작하면 됩니다."
Internationalization,국제화
:func:`django.views.i18n.set_language` now requires a POST request,:func:`django.views.i18n.set_language`는 이제 POST 요청을 필요로 합니다.
"Previously, a GET request was used. The old behavior meant that state (the locale used to display the site) could be changed by a GET request, which is against the HTTP specification's recommendations. Code calling this view must ensure that a POST request is now made, instead of a GET. This means you can no longer use a link to access the view, but must use a form submission of some kind (e.g. a button).","이전에는 GET 요청이 사용되었습니다. 이전 동작은 상태(사이트를 표시하는 데 사용되는 로케일)가 HTTP 사양의 권장 사항에 위배되는 GET 요청에 의해 변경될 수 있음을 의미했습니다. 이 뷰를 호출하는 코드는 이제 GET 대신 POST 요청이 이루어지도록 해야 합니다. 즉, 더 이상 링크를 사용하여 뷰에 액세스할 수 없지만, 일종의 양식 제출(예: 버튼)을 사용해야 합니다."
``_()`` is no longer in builtins,``_()``는 더 이상 내장 함수에 없음
"``_()`` (the callable object whose name is a single underscore) is no longer monkeypatched into builtins -- that is, it's no longer available magically in every module.","``_()``(이름이 단일 밑줄인 호출 가능한 객체)는 더 이상 내장 함수들에 몽키패치되지 않습니다. 즉, 더 이상 모든 모듈에서 사용할 수 없습니다."
"If you were previously relying on ``_()`` always being present, you should now explicitly import ``ugettext`` or ``ugettext_lazy``, if appropriate, and alias it to ``_`` yourself::","이전에 항상 존재하는 ``_()``에 의존했다면, 이제 적절하다면 ``ugettext`` 또는 ``ugettext_lazy``를 명시적으로 임포트하고 직접 ``_``에 별칭을 지정해야 합니다::"
HTTP request/response objects,HTTP 요청/응답 객체
Dictionary access to ``HttpRequest``,``HttpRequest``에 대한 사전 액세스
"``HttpRequest`` objects no longer directly support dictionary-style access; previously, both ``GET`` and ``POST`` data were directly available on the ``HttpRequest`` object (e.g., you could check for a piece of form data by using ``if 'some_form_key' in request`` or by reading ``request['some_form_key']``. This is no longer supported; if you need access to the combined ``GET`` and ``POST`` data, use ``request.REQUEST`` instead.","``HttpRequest`` 개체는 더 이상 사전 스타일 액세스를 직접 지원하지 않습니다. 이전에는 ``if 'some_form_key' in request``를 사용하거나 ``request['some_form_key']``를 읽음으로써 ``GET`` 및 ``POST`` 데이터 모두 ``HttpRequest`` 객체에서 직접 사용할 수 있었습니다. 이것은 더 이상 지원되지 않습니다. 결합된 ``GET`` 및 ``POST`` 데이터에 액세스해야 하는 경우, 대신 ``request.REQUEST``를 사용하십시오."
"It is strongly suggested, however, that you always explicitly look in the appropriate dictionary for the type of request you expect to receive (``request.GET`` or ``request.POST``); relying on the combined ``request.REQUEST`` dictionary can mask the origin of incoming data.",그러나 수신될 것으로 예상되는 요청 유형(``request.GET`` 또는 ``request.POST``)에 대해 항상 적절한 사전을 명시적으로 찾아볼 것을 강력하게 제안합니다. 결합된 ``request.REQUEST`` 사전에 의존하면 들어오는 데이터의 출처를 숨길 수 있습니다.
Accessing ``HTTPResponse`` headers,``HTTPResponse`` 헤더 접근
``django.http.HttpResponse.headers`` has been renamed to ``_headers`` and :class:`~django.http.HttpResponse` now supports containment checking directly. So use ``if header in response:`` instead of ``if header in response.headers:``.,``django.http.HttpResponse.headers``는 ``_headers``로 이름이 바뀌었고 :class:`~django.http.HttpResponse`는 이제 포함 검사를 직접 지원합니다. 따라서 ``if header in response.headers:`` 대신 ``if header in response:``를 사용하십시오.
Generic relations,범용 관계
Generic relations have been moved out of core,범용 관계가 코어에서 이동됨
The generic relation classes -- ``GenericForeignKey`` and ``GenericRelation`` -- have moved into the :mod:`django.contrib.contenttypes` module.,범용 관계 클래스 -- ``GenericForeignKey`` 및 ``GenericRelation`` --은 :mod:`django.contrib.contenttypes` 모듈로 이동했습니다.
:meth:`django.test.Client.login` has changed,:meth:`django.test.Client.login`이 변경됨
Management commands,관리 명령어
Running management commands from your code,코드에서 관리 명령 실행
:mod:`django.core.management` has been greatly refactored.,:mod:`django.core.management`가 크게 리팩토링되었습니다.
"Calls to management services in your code now need to use ``call_command``. For example, if you have some test code that calls flush and load_data::","코드에서 관리 서비스에 대한 호출은 이제 ``call_command``를 사용해야 합니다. 예를 들어, flush 및 load_data를 호출하는 테스트 코드가 있는 경우::"
...you'll need to change this code to read::,...이 코드를 다음과 같이 변경해야 합니다::
Subcommands must now precede options,이제 하위 명령이 옵션 앞에 와야 합니다.
``django-admin.py`` and ``manage.py`` now require subcommands to precede options. So:,``django-admin.py`` 및 ``manage.py``는 이제 옵션 앞에 하위 명령이 필요합니다. 그래서:
...no longer works and should be changed to:,...더 이상 작동하지 않으며 다음으로 변경해야 합니다.
``Feed.__init__`` has changed,``Feed.__init__``이 변경되었습니다.
"The ``__init__()`` method of the syndication framework's ``Feed`` class now takes an ``HttpRequest`` object as its second parameter, instead of the feed's URL. This allows the syndication framework to work without requiring the sites framework. This only affects code that subclasses ``Feed`` and overrides the ``__init__()`` method, and code that calls ``Feed.__init__()`` directly.","신디케이션 프레임워크의 ``Feed`` 클래스의 ``__init__()`` 메서드는 이제 피드의 URL 대신 ``HttpRequest`` 객체를 두 번째 매개변수로 사용합니다. 이를 통해 사이트 프레임워크 없이 신디케이션 프레임워크가 작동할 수 있습니다. 이는 ``Feed``를 하위 클래스로 만들고, ``__init__()`` 메서드를 재정의하는 코드와 ``Feed.__init__()``를 직접 호출하는 코드에만 영향을 미칩니다."
Data structures,데이터 구조
``SortedDictFromList`` is gone,``SortedDictFromList`` 사라짐
``django.newforms.forms.SortedDictFromList`` was removed. ``django.utils.datastructures.SortedDict`` can now be instantiated with a sequence of tuples.,``django.newforms.forms.SortedDictFromList``가 제거되었습니다. ``django.utils.datastructures.SortedDict``는 이제 일련의 튜플로 인스턴스화될 수 있습니다.
To update your code:,코드를 업데이트하려면:
Use ``django.utils.datastructures.SortedDict`` wherever you were using ``django.newforms.forms.SortedDictFromList``.,``django.newforms.forms.SortedDictFromList``를 사용하던 곳에서 ``django.utils.datastructures.SortedDict``를 사용하십시오.
"Because ``django.utils.datastructures.SortedDict.copy`` doesn't return a deepcopy as ``SortedDictFromList.copy()`` did, you will need to update your code if you were relying on a deepcopy. Do this by using ``copy.deepcopy`` directly.","``django.utils.datastructures.SortedDict.copy``는 ``SortedDictFromList.copy()``처럼 깊은 복사본을 반환하지 않기 때문에, 깊은 복사본에 의존하는 경우 코드를 업데이트해야 합니다. ``copy.deepcopy``를 직접 사용하여 이를 수행하십시오."
Database backend functions,데이터베이스 백엔드 기능
Database backend functions have been renamed,데이터베이스 백엔드 기능의 이름이 변경되었습니다.
"Almost *all* of the database backend-level functions have been renamed and/or relocated. None of these were documented, but you'll need to change your code if you're using any of these functions, all of which are in :mod:`django.db`:","거의 *모든* 데이터베이스 백엔드 수준 함수들의 이름이 바뀌거나 재배치되었습니다. 이 중 어느 것도 문서화되지는 않았지만, 이러한 함수들을 사용하는 경우 코드를 변경해야 합니다. 이 함수들은 모두 :mod:`django.db`에 있습니다."
``backend.get_autoinc_sql``,``backend.get_autoinc_sql``
``connection.ops.autoinc_sql``,``connection.ops.autoinc_sql``
``backend.get_date_extract_sql``,``backend.get_date_extract_sql``
``connection.ops.date_extract_sql``,``connection.ops.date_extract_sql``
``backend.get_date_trunc_sql``,``backend.get_date_trunc_sql``
``connection.ops.date_trunc_sql``,``connection.ops.date_trunc_sql``
``backend.get_datetime_cast_sql``,``backend.get_datetime_cast_sql``
``connection.ops.datetime_cast_sql``,``connection.ops.datetime_cast_sql``
``backend.get_deferrable_sql``,``backend.get_deferrable_sql``
``connection.ops.deferrable_sql``,``connection.ops.deferrable_sql``
``backend.get_drop_foreignkey_sql``,``backend.get_drop_foreignkey_sql``
``connection.ops.drop_foreignkey_sql``,``connection.ops.drop_foreignkey_sql``
``backend.get_fulltext_search_sql``,``backend.get_fulltext_search_sql``
``connection.ops.fulltext_search_sql``,``connection.ops.fulltext_search_sql``
``backend.get_last_insert_id``,``backend.get_last_insert_id``
``connection.ops.last_insert_id``,``connection.ops.last_insert_id``
``backend.get_limit_offset_sql``,``backend.get_limit_offset_sql``
``connection.ops.limit_offset_sql``,``connection.ops.limit_offset_sql``
``backend.get_max_name_length``,``backend.get_max_name_length``
``connection.ops.max_name_length``,``connection.ops.max_name_length``
``backend.get_pk_default_value``,``backend.get_pk_default_value``
``connection.ops.pk_default_value``,``connection.ops.pk_default_value``
``backend.get_random_function_sql``,``backend.get_random_function_sql``
``connection.ops.random_function_sql``,``connection.ops.random_function_sql``
``backend.get_sql_flush``,``backend.get_sql_flush``
``connection.ops.sql_flush``,``connection.ops.sql_flush``
``backend.get_sql_sequence_reset``,``backend.get_sql_sequence_reset``
``connection.ops.sequence_reset_sql``,``connection.ops.sequence_reset_sql``
``backend.get_start_transaction_sql``,``backend.get_start_transaction_sql``
``connection.ops.start_transaction_sql``,``connection.ops.start_transaction_sql``
``backend.get_tablespace_sql``,``backend.get_tablespace_sql``
``connection.ops.tablespace_sql``,``connection.ops.tablespace_sql``
``backend.quote_name``,``backend.quote_name``
``connection.ops.quote_name``,``connection.ops.quote_name``
``backend.get_query_set_class``,``backend.get_query_set_class``
``connection.ops.query_set_class``,``connection.ops.query_set_class``
``backend.get_field_cast_sql``,``backend.get_field_cast_sql``
``connection.ops.field_cast_sql``,``connection.ops.field_cast_sql``
``backend.get_drop_sequence``,``backend.get_drop_sequence``
``connection.ops.drop_sequence_sql``,``connection.ops.drop_sequence_sql``
``backend.OPERATOR_MAPPING``,``backend.OPERATOR_MAPPING``
``connection.operators``,``connection.operators``
``backend.allows_group_by_ordinal``,``backend.allows_group_by_ordinal``
``connection.features.allows_group_by_ordinal``,``connection.features.allows_group_by_ordinal``
``backend.allows_unique_and_pk``,``backend.allows_unique_and_pk``
``connection.features.allows_unique_and_pk``,``connection.features.allows_unique_and_pk``
``backend.autoindexes_primary_keys``,``backend.autoindexes_primary_keys``
``connection.features.autoindexes_primary_keys``,``connection.features.autoindexes_primary_keys``
``backend.needs_datetime_string_cast``,``backend.needs_datetime_string_cast``
``connection.features.needs_datetime_string_cast``,``connection.features.needs_datetime_string_cast``
``backend.needs_upper_for_iops``,``backend.needs_upper_for_iops``
``connection.features.needs_upper_for_iops``,``connection.features.needs_upper_for_iops``
``backend.supports_constraints``,``backend.supports_constraints``
``connection.features.supports_constraints``,``connection.features.supports_constraints``
``backend.supports_tablespaces``,``backend.supports_tablespaces``
``connection.features.supports_tablespaces``,``connection.features.supports_tablespaces``
``backend.uses_case_insensitive_names``,``backend.uses_case_insensitive_names``
``connection.features.uses_case_insensitive_names``,``connection.features.uses_case_insensitive_names``
``backend.uses_custom_queryset``,``backend.uses_custom_queryset``
``connection.features.uses_custom_queryset``,``connection.features.uses_custom_queryset``
Django 1.0.1 release notes,Django 1.0.1 릴리즈 노트
Welcome to Django 1.0.1!,Django 1.0.1에 오신 것을 환영합니다!
"This is the first ""bugfix"" release in the Django 1.0 series, improving the stability and performance of the Django 1.0 codebase. As such, Django 1.0.1 contains no new features (and, pursuant to :doc:`our compatibility policy </misc/api-stability/>`, maintains backwards compatibility with Django 1.0), but does contain a number of fixes and other improvements. Django 1.0.1 is a recommended upgrade for any development or deployment currently using or targeting Django 1.0.","이것은 Django 1.0 시리즈의 첫 번째 ""버그 수정"" 릴리스로, Django 1.0 코드베이스의 안정성과 성능을 향상시킵니다. 따라서 Django 1.0.1에는 새로운 기능이 포함되어 있지 않지만(:doc:`Django 1.0과의 호환성 정책 </misc/api-stability/>`에 따라) 많은 수정 및 기타 개선 사항이 포함되어 있습니다. Django 1.0.1은 현재 Django 1.0을 사용하거나 대상으로 하는 모든 개발 또는 배포에 권장되는 업그레이드입니다."
Fixes and improvements in Django 1.0.1,Django 1.0.1의 수정 및 개선 사항
"Django 1.0.1 contains over two hundred fixes to the original Django 1.0 codebase; full details of every fix are available in `the history of the 1.0.X branch`_, but here are some of the highlights:",Django 1.0.1에는 오리지널 Django 1.0 코드베이스에 대한 200개 이상의 수정 사항이 포함되어 있습니다. 모든 수정 사항에 대한 자세한 내용은 `1.0.X 브랜치 기록`_에서 확인할 수 있지만 다음은 몇 가지 주요 사항들입니다:
"Several fixes in ``django.contrib.comments``, pertaining to RSS feeds of comments, default ordering of comments and the XHTML and internationalization of the default templates for comments.","주석의 RSS 피드, 주석의 기본 순서 및 XHTML 및 주석에 대한 기본 템플릿의 국제화와 관련된 ``django.contrib.comments``의 몇 가지 수정 사항입니다."
"Multiple fixes for Django's support of Oracle databases, including pagination support for GIS QuerySets, more efficient slicing of results and improved introspection of existing databases.","GIS QuerySets에 대한 페이지네이션 지원, 보다 효율적인 결과 슬라이싱 및 기존 데이터베이스의 향상된 내부 검사를 포함하고 있는 Django의 Oracle 데이터베이스 지원에 대한 여러 가지 수정 사항입니다."
"Several fixes for query support in the Django object-relational mapper, including repeated setting and resetting of ordering and fixes for working with ``INSERT``-only queries.","Django 개체 관계형 매퍼의 쿼리 지원에 대한 몇 가지 수정 사항에는 순서의 반복 설정 및 재설정, ``INSERT`` 전용 쿼리 작업에 대한 수정 사항이 포함됩니다."
Multiple fixes for inline forms in formsets.,양식 집합의 인라인 양식에 대한 여러 수정 사항.
Multiple fixes for ``unique`` and ``unique_together`` model constraints in automatically-generated forms.,자동 생성 양식의 ``unique`` 및 ``unique_together`` 모델 제약 조건에 대한 여러 수정 사항들.
Fixed support for custom callable ``upload_to`` declarations when handling file uploads through automatically-generated forms.,"자동 생성된 양식을 통해 파일 업로드를 처리할 때, 호출 가능한 사용자 정의 ``upload_to`` 선언에 대한 지원이 수정되었습니다."
Fixed support for sorting an admin change list based on a callable attributes in ``list_display``.,``list_display``에서 호출 가능한 속성을 기반으로 관리자 변경 목록 정렬에 대한 지원을 수정했습니다.
"A fix to the application of autoescaping for literal strings passed to the ``join`` template filter. Previously, literal strings passed to ``join`` were automatically escaped, contrary to :ref:`the documented behavior for autoescaping and literal strings <string-literals-and-automatic-escaping>`. Literal strings passed to ``join`` are no longer automatically escaped, meaning you must now manually escape them; this is an incompatibility if you were relying on this bug, but not if you were relying on escaping behaving as documented.","``join`` 템플릿 필터에 전달된 리터럴 문자열에 대한 자동 이스케이프 적용이 수정되었습니다. 이전에는 :ref:`자동 이스케이프 및 리터럴 문자열 <string-literals-and-automatic-escaping>에 대한 문서화된 동작`과 다르게 ``join``에 전달된 리터럴 문자열은 자동으로 이스케이프되었습니다. 이제 ``join``에 전달된 리터럴 문자열은 더 이상 자동으로 이스케이프되지 않습니다. 즉, 이제 수동으로 이스케이프해야 합니다. 이 변경 사항은 기존에 이 버그에 의존했었을 경우 비호환적이지만, 문서화된 대로 행동하는 이스케이프에 의존했었을 경우에는 그렇지 않습니다."
Improved and expanded translation files for many of the languages Django supports by default.,Django가 기본적으로 지원하는 많은 언어에 대해 개선되고 확장된 번역 파일입니다.
"And as always, a large number of improvements to Django's documentation, including both corrections to existing documents and expanded and new documentation.","그리고 항상 그렇듯이, 기존 문서에 대한 수정과 확장되고 새로운 문서를 포함하여 Django 문서에 대한 많은 개선 사항이 있습니다."
Django 1.0.2 release notes,Django 1.0.2 릴리즈 노트
Welcome to Django 1.0.2!,Django 1.0.2에 오신 것을 환영합니다!
"This is the second ""bugfix"" release in the Django 1.0 series, improving the stability and performance of the Django 1.0 codebase. As such, Django 1.0.2 contains no new features (and, pursuant to :doc:`our compatibility policy </misc/api-stability>`, maintains backwards compatibility with Django 1.0.0), but does contain a number of fixes and other improvements. Django 1.0.2 is a recommended upgrade for any development or deployment currently using or targeting Django 1.0.","이것은 Django 1.0 시리즈의 두 번째 ""버그 수정"" 릴리스로, Django 1.0 코드베이스의 안정성과 성능을 향상시킵니다. 따라서 Django 1.0.2에는 새로운 기능이 포함되어 있지 않지만(그리고 :doc:`Django 1.0.0과의 호환성 정책 </misc/api-stability>`에 따라) 많은 수정 사항 및 기타 개선 사항이 포함되어 있습니다. Django 1.0.2는 현재 Django 1.0을 사용하거나 대상으로 하는 모든 개발 또는 배포에 권장되는 업그레이드입니다."
Fixes and improvements in Django 1.0.2,Django 1.0.2의 수정 및 개선 사항
"The primary reason behind this release is to remedy an issue in the recently-released Django 1.0.1; the packaging scripts used for Django 1.0.1 omitted some directories from the final release package, including one directory required by ``django.contrib.gis`` and part of Django's unit-test suite.",이 릴리스의 주된 이유는 최근 릴리스된 Django 1.0.1의 문제를 해결하기 위한 것입니다. Django 1.0.1에 사용된 패키징 스크립트는 ``django.contrib.gis``에 필요한 디렉토리와 Django의 단위 테스트 스위트의 일부를 포함하여 최종 릴리스 패키지에서 일부 디렉토리를 생략했습니다.
"Django 1.0.2 contains updated packaging scripts, and the release package contains the directories omitted from Django 1.0.1. As such, this release contains all of the fixes and improvements from Django 1.0.1; see :doc:`the Django 1.0.1 release notes </releases/1.0.1>` for details.","Django 1.0.2에는 업데이트된 패키징 스크립트가 포함되어 있으며, 릴리스 패키지에는 Django 1.0.1에서 생략된 디렉토리가 포함되어 있습니다. 따라서 이 릴리스에는 Django 1.0.1의 모든 수정 사항과 개선 사항이 포함되어 있습니다. 자세한 내용은 :doc:`Django 1.0.1 릴리스 노트 </releases/1.0.1>`을 참조하십시오."
``mysite/urls.py``,``mysite/urls.py``
``polls/urls.py``,``polls/urls.py``
