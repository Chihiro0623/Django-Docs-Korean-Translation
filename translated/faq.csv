source (en),translation (ko)
Django won't bother displaying the filter for a ``ManyToManyField`` if there are no related objects.,장고는 관련된 개체가 없으면 ``ManyToManyField``에 대한 필터를 나타내지 않습니다.
"For example, if your :attr:`~django.contrib.admin.ModelAdmin.list_filter` includes :doc:`sites </ref/contrib/sites>`, and there are no sites in your database, it won't display a ""Site"" filter. In that case, filtering by site would be meaningless.","예를 들어, attr:`~django.contrib.admin.ModelAdmin.list_filter`\ 가 :doc:`sites </ref/contrib/sites>` 를 포함하고 있고 여러분의 데이터베이스에 사이트가 없다면, 'Site' 필터를 표시하지 않을 것 입니다. 이러한 경우에 site로 필터링하는 것은 의미가 없습니다."
"Another reason that a bug might be ignored for a while is if the bug is a symptom of a larger problem. While we can spend time writing, testing and applying lots of little patches, sometimes the right solution is to rebuild. If a rebuild or refactor of a particular component has been proposed or is underway, you may find that bugs affecting that component will not get as much attention. Again, this is a matter of prioritizing scarce resources. By concentrating on the rebuild, we can close all the little bugs at once, and hopefully prevent other little bugs from appearing in the future.","버그가 무시되어질 수 있는 또 다른 이유는 버그가 큰 문제의 징후일 수 있기 때문입니다. 저희들이 굉장히 많은 작은 패치들을 작성하고 테스팅할 때, 가끔은 새로 빌드하는 것이 올바른 방법일 경우가 있습니다. 만약 특정 요소들을 새로 빌드하거나 재개발하는 것으로 결정되거나 진행중에 있다면, 해당 요소에 영향을 주는 버그들은 많은 관심을 받지 못할 것입니다. 다시한번 말씀드리면, 이것은 적은 자원에 따른 우선순위를 정하는 문제입니다. 새로 빌드하는것에 집중하므로써, 저희들은 한번에 작은 버그들을 닫고, 미래에 발생할 작은 버그들을 방지할 수 있습니다."
"Whatever the reason, please keep in mind that while you may hit a particular bug regularly, it doesn't necessarily follow that every single Django user will hit the same bug. Different users use Django in different ways, stressing different parts of the code under different conditions. When we evaluate the relative priorities, we are generally trying to consider the needs of the entire community, instead of prioritizing the impact on one particular user. This doesn't mean that we think your problem is unimportant -- just that in the limited time we have available, we will always err on the side of making 10 people happy rather than making a single person happy.","이유가 무엇이든 간에, 당신이 어떤 버그를 주기적으로 발생시킨다고 해서 다른 장고 유저들 모두가 같은 버그를 발생시키지 않는다는 것을 알아야 합니다. 장고를 사용하는 사람들 각각은 서로 다른 환경에서 서로 다른 부분의 코드를 강조하여 장고를 다른 방식으로 장고를 사용합니다. 저희가 상대적인 우선 순위를 정할 때에는, 일반적으로 특정 한 사용자의 영향을 우선시하기보다는 전체 커뮤니티의 요구를 반영하려고 노력합니다. 이것은 당신이 가지고 있는 문제가 중요하지 않다는 의미가 아니라, 저희가 가지고 있는 시간이 제한되어 있기 때문입니다. 저희들은 항상 한 사람을 행복하게 하기보다 10명을 행복하게 하는 잘못을 범하고 있습니다."
"I'm sure my ticket is absolutely 100% perfect, can I mark it as ""Ready For Checkin"" myself?","100% 완벽하다고 확신할 수 있는 티켓을 직접 ""체크인 준비 완료""로 표시할 수 있습니까?"
"Sorry, no. It's always better to get another set of eyes on a ticket. If you're having trouble getting that second set of eyes, see questions above.",죄송합니다. 티켓을 확인해 줄 다른 사람을 찾는 것이 무조건 더 좋습니다. 다른 사람을 찾는 데 문제가 있는 경우 위의 질문을 참조하세요.
"Django grew from a very practical need: World Online, a newspaper web operation, is responsible for building intensive web applications on journalism deadlines. In the fast-paced newsroom, World Online often has only a matter of hours to take a complicated web application from concept to public launch.",장고는 굉장히 실용적인 요구에 의해 만들어 졌습니다.: World Online이라는 뉴스 웹 관리 시스템은 마감 기한에 맞추는 웹 애플리케이션을 만드는 책임이 있었습니다. 빠르게 변화하는 뉴스룸에서 World Online은 복잡한 웹 애플리케이션을 구상해서 공개하기 까지 단 몇시간여 밖에 주어지지 않곤 했습니다.
"At the same time, the World Online web developers have consistently been perfectionists when it comes to following best practices of web development.","동시에, World Online의 웹 개발자들은 웹 개발의 최고의 시도를 따르는 것에 관해서는 완벽주의자들 이었습니다."
"In fall 2003, the World Online developers (Adrian Holovaty and Simon Willison) ditched PHP and began using Python to develop its websites. As they built intensive, richly interactive sites such as Lawrence.com, they began to extract a generic web development framework that let them build web applications more and more quickly. They tweaked this framework constantly, adding improvements over two years.","2003년 가을, World Online의 개발자들(Adrian Holovat and Simon Willison)은 PHP를 버리고 파이썬을 웹을 개발하는데 사용하였습니다. Lawrence.com과 같은 탄탄하고 굉장히 상호작용적인 사이트들을 만들면서, 그들은 웹 애플리케이션을 더 빠르게 만들 수 있는 웹 개발 프래임워크 속성들을 추출해내기 시작하였습니다. 그들은 이 프래임워크를 지속적으로 조작하고 2년간에 걸쳐 향상시켰습니다."
"Django uses a ""shared-nothing"" architecture, which means you can add hardware at any level -- database servers, caching servers or web/application servers.","장고는 ""shared-nothing""이라는 구조를 사용합니다. 이것은 데이터베이스 서버, 캐싱 서버 혹은 웹 애플리케이션 서버의 어느 단에서도 하드웨어를 추가할 수 있다는 의미입니다."
"Django was originally developed at World Online, the web department of a newspaper in Lawrence, Kansas, USA. Django's now run by an international `team of volunteers <https://www.djangoproject.com/foundation/teams/>`_.",장고는 처음에는 미국 캔자스시티에 Lawrence 신문 웹 부서 World Online에서 개발되었습니다. 장고는 현재 자원봉사팀에 의해 작동되고 있습니다. `team of volunteers <https://www.djangoproject.com/foundation/teams/>`_.
"We're well aware that there are other awesome web frameworks out there, and we're not averse to borrowing ideas where appropriate. However, Django was developed precisely because we were unhappy with the status quo, so please be aware that ""because <Framework X> does it"" is not going to be sufficient reason to add a given feature to Django.","저희들도 굉장한 웹 프레임워크들이 있는것을 잘 알고있습니다. 그리고, 아이디어를 빌려오는 것을 싫어하지 않습니다. 하지만 장고는 현재 상태에 행복하지 않았기 때문에 만들어 졌습니다. 따라서 ""<Framework X>는 하는데요""라는 말은 장고에 기능을 추가할 만한 충분한 이유가 되지 않습니다."
"No, Django is not a CMS, or any sort of ""turnkey product"" in and of itself. It's a web framework; it's a programming tool that lets you build websites.",아닙니다. 장고는 컨텐츠관리 시스템같은것이 아닙니다. 이것은 웹 프레임워크이고 당신이 웹사이트를 만드는데 도움을 주는 프로그래밍 툴입니다.
"Yes, Django's automatic admin site is fantastic and timesaving -- but the admin site is one module of Django the framework. Furthermore, although Django has special conveniences for building ""CMS-y"" apps, that doesn't mean it's not just as appropriate for building ""non-CMS-y"" apps (whatever that means!).","네, 장고의 자동화된 관리자 사이트는 환상적이고 시간을 아껴줍니다 -- 그러나 관리자 사이트는 장고의 한 모듈일 뿐입니다. 또한, 비록 장고가 ""CMS-y"" 앱들을 만드는데 특별한 편리한 점들을 가지고 있지만, 그렇다고 이것이 ""non-CMS-y""앱들을 만드는데 적합하지 않다는 것을 의미하지 않습니다."
"The Django docs are available in the ``docs`` directory of each Django tarball release. These docs are in reST (reStructuredText) format, and each text file corresponds to a web page on the official Django site.","장고 문서는 각 tarball포맷 릴리즈의 ``docs`` 디렉토리 안에 있습니다. 이 문서들은 reST(reStructedText) 형식을 따르고, 각각의 텍스트 파일은 오프라인 장고 사이트의 페이지와 연동됩니다."
"If you need a web address, use https://www.djangoproject.com/.","웹 주소가 필요하시다면, ""https://www.djangoproject.com/""을 사용하세요."
"First, please check if your question is answered on the :doc:`FAQ </faq/index>`. Also, search for answers using your favorite search engine, and in `the forum`_.",먼저 :doc:`FAQ </faq/index>`에서 질문에 대한 답변을 확인하세요. 또한 즐겨찾는 검색 엔진과 `포럼`_을 사용하여 답변을 검색하십시오.
"If you can't find an answer, please take a few minutes to formulate your question well. Explaining the problems you are facing clearly will help others help you. See the StackOverflow guide on `asking good questions`_.",답변을 찾을 수 없으면 몇 분 정도 시간을 내어 질문을 잘 공식화하십시오. 당신이 직면한 문제를 명확하게 설명하면 다른 사람들이 당신을 더 잘 도울 수 있습니다. '좋은 질문하기'_에 대한 StackOverflow 가이드를 참조하세요.
"Then, please post it in one of the following channels:","이후, 다음 채널들 중 하나에 게시해 주세요:"
"The Django Forum section `""Using Django""`_. This is for web-based discussions.","장고 포럼 섹션 `""장고 사용하기""`_. 이것은 웹 기반 토론을 위한 섹션입니다."
The |django-users| mailing list. This is for email-based discussions.,|django-users| 메일링 리스트. 이것은 이메일 기반 토론을 위한 것입니다.
"The `#django IRC channel`_ on the Libera.Chat IRC network. This is for chat-based discussions. If you're new to IRC, see the `Libera.Chat documentation`_ for different ways to connect.",Libera.Chat IRC 네트워크의 `#django IRC 채널`_. 이 채널은 채팅 기반 토론을 위한 것입니다. IRC를 처음 사용하는 경우 다양한 연결 방법에 대해 `Libera.Chat 문서`_를 참조하세요.
"In all these channels please abide by the `Django Code of Conduct`_. In summary, being friendly and patient, considerate, respectful, and careful in your choice of words.","이 모든 채널에서 `장고 행동 강령`_을 준수하십시오. 요약하면, 친절하고 참을성 있고 사려 깊고 존중하며 단어 선택에 신중을 기해야 합니다."
"As with most open-source projects, the folks on these channels are volunteers. If nobody has answered your question, it may be because nobody knows the answer, it may be because nobody can understand the question, or it may be that everybody that can help is busy.","대부분의 오픈소스 프로젝트들 같이, 이 채널들의 사람들은 자원 봉사자들입니다. 아무도 질문에 대한 답변을 하지 않았다면, 아무도 그 질문에 대한 답변을 모르거나, 질문을 이해할 수 없거나, 아니면 도와줄만한 사람이 모두 바쁜것 일 수도 있습니다."
You can also try asking on a different channel. But please don't post your question in all three channels in quick succession.,다른 채널에서 물어볼 수도 있습니다. 그러나 같은 질문을 세 채널 모두에 빠르게 연속해서 게시하지는 말아 주십시오.
"You might notice we have a second mailing list, called |django-developers|. This list is for discussion of the development of Django itself. Please don't email support questions to this mailing list. Asking a tech support question there is considered impolite, and you will likely be directed to ask on |django-users|.",|django-developers|라는 두 번째 메일링 리스트를 확인하셨을 것입니다. 이 목록은 장고 자체의 개발에 대한 토론을 위한 것입니다. 이 메일링 리스트에 지원 질문을 이메일로 보내지 마십시오. 거기에서 기술 지원 질문을 하는 것은 무례한 것으로 간주되며 |django-users|에 질문하도록 안내될 것입니다.
"Due to the sensitive nature of security issues, we ask that if you think you have found a security problem, *please* don't post a message on the forum, IRC, or one of the public mailing lists. Django has a :ref:`policy for handling security issues <reporting-security-issues>`; while a defect is outstanding, we would like to minimize any damage that could be inflicted through public knowledge of that defect.","보안 문제의 민감한 특성으로 인해, 만약 당신이 보안 문제를 발견한다면 *제발* 포럼, IRC, 또는 공개된 메일링 리스트에 올리지 말아 주시기 바랍니다. 장고는 :ref:`policy for handling security issues <reporting-security-issues>`;를 갖고 있습니다. 문제가 크다면, 해당 결점을 많은 사람들이 앎으로써 발생되는 문제점을 최소화 하기 위함 입니다. "
For a development environment -- if you just want to experiment with Django -- you don't need to have a separate web server installed or database server.,단순히 장고를 학습하귀 위한 개발환경 구축을 위해서는 별도의 웹 서버를 설치할 필요가 없고 데이터베이스 서버가 필요하지 않습니다.
"Django comes with its own :djadmin:`lightweight development server<runserver>`. For a production environment, Django follows the WSGI spec, :pep:`3333`, which means it can run on a variety of web servers. See :doc:`Deploying Django </howto/deployment/index>` for more information.",장고는 자체 :djadmin:`경량 개발 서버<runserver>`와 함께 제공됩니다. 운영 환경의 경우 장고는 WSGI 사양인 :pep:`3333`을 따르므로 다양한 웹 서버에서 실행할 수 있습니다. 자세한 내용은 :doc:`Django 배포 </howto/deployment/index>`를 참조하세요.
"3.5, 3.6, 3.7, 3.8 (added in 2.2.8), 3.9 (added in 2.2.17)","3.5, 3.6, 3.7, 3.8 (2.2.8에 추가됨), 3.9 (2.2.17에 추가됨)"
"3.6, 3.7, 3.8, 3.9 (added in 3.1.3)","3.6, 3.7, 3.8, 3.9 (3.1.3에 추가됨)"
3.2,3.2
"3.6, 3.7, 3.8, 3.9, 3.10 (added in 3.2.9)","3.6, 3.7, 3.8, 3.9, 3.10 (3.2.9에 추가됨)"
4.0,4.0
"3.8, 3.9, 3.10","3.8, 3.9, 3.10"
4.1,4.1
"3.8, 3.9, 3.10, 3.11 (added in 4.1.3)","3.8, 3.9, 3.10, 3.11 (4.1.3에 추가됨)"
"Typically, we will support a Python version up to and including the first Django LTS release whose security support ends after security support for that version of Python ends. For example, Python 3.3 security support ended September 2017 and Django 1.8 LTS security support ended April 2018. Therefore Django 1.8 is the last version to support Python 3.3.","일반적으로, 장고 LTS버전과 파이썬 버전들을 지원하는데 해당 버전의 파이썬 보안 지원이 끝나기 전까지 지원합니다. 예를들면 파이썬 3.3 보안 지원은 2017년 9월에 종료되었고 Django 1.8 LTS는 2018년 4월에 종료되었습니다. 따라서 Django 1.8은 Python3.3을 지원하는 마지막 버전입니다."
"You don't lose anything in Django by using an older release, but you don't take advantage of the improvements and optimizations in newer Python releases. Third-party applications for use with Django are free to set their own version requirements.",예전 릴리즈의 장고를 사용한다고 잃는것은 아무것도 없습니다. 하지만 새로운 파이썬의 발전과 최적화 혜택을 받을 수 없습니다. 써드파티 애플리케이션 또한 그들의 버전 요구를 정할 수 있습니다.
Can I use Django with a preexisting database?,장고를 이미 존재하는 데이터베이스와 함께 사용할 수 있나요?
"But this isn't an issue in practice, because there's nothing stopping you from adding other constraints (using the ``unique_together`` model option or creating the constraint directly in your database), and enforcing the uniqueness at that level. Single-column primary keys are needed for things such as the admin interface to work; e.g., you need a single value to specify an object to edit or delete.","그러나 이것은 실제로 문제가 되지 않습니다. 왜냐하면 다른 제약 조건을 추가하거나(``unique_together`` 모델 옵션을 사용하거나 데이터베이스에서 직접 제약 조건을 생성하는 것), 해당 수준에서 유일함을 강제하는 것을 막을 수 없기 때문입니다. 단일 열 기본 키는 관리자 인터페이스와 같은 작업에 필요합니다. 예를 들어 편집하거나 삭제할 개체를 지정하려면 단일 값이 필요합니다."
You can take a look on `the wiki page`_ which discusses some projects.,`위키 페이지`_에서 여러 프로젝트들에 대해 논의해 볼 수 있습니다.
":doc:`django-admin </ref/django-admin>` should be on your system path if you installed Django via ``pip``. If it's not in your path, ensure you have your virtual environment activated and you can try running the equivalent command ``python -m django``.",":doc:`django-admin </ref/django-admin>`은 ``pip``를 통해 장고를 설치한 경우 시스템 경로에 있어야 합니다. 만약 경로에 없으면 가상 환경이 활성화되어 있는지 확인하고, 명령 ``python -m django``를 실행해 확인할 수 있습니다."
The environment variable :envvar:`DJANGO_SETTINGS_MODULE` is set to a fully-qualified Python module (i.e. ``mysite.settings``).,환경변수 :envvar:`DJANGO_SETTINGS_MODULE`는 파이썬 모듈로서 충분하게 만들어 졌습니다 (i.e. ``mysite.settings``). 
"In your settings file, you'll need to define :setting:`MEDIA_ROOT` as the full path to a directory where you'd like Django to store uploaded files. (For performance, these files are not stored in the database.) Define :setting:`MEDIA_URL` as the base public URL of that directory. Make sure that this directory is writable by the web server's user account.","당신의 설정 파일에, 장고가 업로드 할 디렉토리의 전체 경로를 :setting:`MEDIA_ROOT`에 정의해야 합니다. ( 성능을 위해서 이 파일들은 데이터베이스에 저장되지 않습니다.). :setting:`MEDIA_URL` 기본 공개 URL 디렉토리로 정의하세요. 또한 웹서버의 사용자 계정으로 이 디렉토리에 쓰기가 가능하도록 해야 합니다. "
"Sometimes your templates all need the same thing. A common example would be dynamically generated menus. At first glance, it seems logical to add a common dictionary to the template context.","가끔은 당신의 템플릿들이 같은 것을 필요로 합니다. 가장 보편적인 예시는 자동적으로 만들어지는 식단입니다. 첫 눈에 보면, 템플릿 context에 공유하는 딕셔너리를 추가하는것이 논리적으로 보입니다."
The best way to do this in Django is to use a ``RequestContext``. Details on how to do this are here: :ref:`subclassing-context-requestcontext`.,장고에서 이를 수행하는 가장 좋은 방법은 ``RequestContext``를 사용하는 것입니다. 이 작업을 수행하는 방법에 대한 자세한 내용은 :ref:`subclassing-context-requestcontext`에서 확인할 수 있습니다.
