source (en),translation (ko)
"This document describes how to make use of external authentication sources (where the web server sets the ``REMOTE_USER`` environment variable) in your Django applications.  This type of authentication solution is typically seen on intranet sites, with single sign-on solutions such as IIS and Integrated Windows Authentication or Apache and `mod_authnz_ldap`_, `CAS`_, `Cosign`_, `WebAuth`_, `mod_auth_sspi`_, etc.","이 문서는 Django 애플리케이션에서 외부 인증 소스(``REMOTE_USER`` 환경변수를 설정한 웹서버)를 사용하는 방법을 기술합니다. 이러한 인증 방법은 대개 인트라넷, IIS와 통합된 윈도우즈 인증 또는 Apache의 `mod_authnz_ldap`_, `CAS`_, `WebAuth`_, `mod_auth_sspi`_ 등과 같은 싱글 사인온 솔루션에서 볼 수 있습니다."
"When the web server takes care of authentication it typically sets the ``REMOTE_USER`` environment variable for use in the underlying application.  In Django, ``REMOTE_USER`` is made available in the :attr:`request.META <django.http.HttpRequest.META>` attribute.  Django can be configured to make use of the ``REMOTE_USER`` value using the ``RemoteUserMiddleware`` or ``PersistentRemoteUserMiddleware``, and :class:`~django.contrib.auth.backends.RemoteUserBackend` classes found in :mod:`django.contrib.auth`.",웹 서버에서 인증을 관리할 때 대개 내부 어플리케이션을 사용하기 위해 ``REMOTE_USER`` 환경 변수를 설정합니다. ``REMOTE_USER`` 값은 ``RemoteUserMiddleware`` 혹은 ``PersistentRemoteUserMiddleware``\에서 사용됩니다. :mod:`django.contrib.auth`\에서 :class:`~django.contrib.auth.backends.RemoteUserBackend` 클래스를 찾을 수 있습니다.
How to use Django's CSRF protection,장고의 CSRF 보호를 사용하는 방법
"To take advantage of CSRF protection in your views, follow these steps:",당신의 뷰에서 CSRF 보호를 활용하려면 다음 단계를 따르십시오:
"The CSRF middleware is activated by default in the :setting:`MIDDLEWARE` setting. If you override that setting, remember that ``'django.middleware.csrf.CsrfViewMiddleware'`` should come before any view middleware that assume that CSRF attacks have been dealt with.","CSRF 미들웨어는 :setting:`MIDDLEWARE` 설정에서 기본적으로 활성화되어 있습니다. 해당 설정을 덮어쓰는 경우에는, CSRF 공격이 처리되었다고 가정하는 모든 뷰 미들웨어 앞에 ``'django.middleware.csrf.CsrfViewMiddleware'``가 와야 함을 기억하십시오."
"If you disabled it, which is not recommended, you can use :func:`~django.views.decorators.csrf.csrf_protect` on particular views you want to protect (see below).","사용하지 않도록 설정한 경우(권장하지 않음), 보호하려는 특정 뷰에서 :func:`~django.views.decorators.csrf.csrf_protect`를 사용할 수 있습니다(아래 참조)."
"In any template that uses a POST form, use the :ttag:`csrf_token` tag inside the ``<form>`` element if the form is for an internal URL, e.g.:","POST 양식을 사용하는 모든 템플릿에서, 양식이 내부 URL용인 경우 ``<form>`` 요소 내부에 :ttag:`csrf_token` 태그를 사용하세요. 예:"
"This should not be done for POST forms that target external URLs, since that would cause the CSRF token to be leaked, leading to a vulnerability.",외부 URL을 대상으로 하는 POST 양식에 대해서는 이렇게 할 수 없습니다. CSRF 토큰이 누출되어 취약점이 발생할 수 있기 때문입니다.
"In the corresponding view functions, ensure that :class:`~django.template.RequestContext` is used to render the response so that ``{% csrf_token %}`` will work properly. If you're using the :func:`~django.shortcuts.render` function, generic views, or contrib apps, you are covered already since these all use ``RequestContext``.","해당 뷰 함수에서 :class:`~django.template.RequestContext`가 응답을 렌더링하는 데 사용되는지 확인하여 ``{% csrf_token %}``이 제대로 작동하도록 하십시오. 만약 :func:`~django.shortcuts.render` 함수, 제네릭 뷰, 또는 contrib apps를 사용하는 경우, 이들은 모두 ``RequestContext``를 사용하므로 확인할 필요가 업습니다."
Using CSRF protection with AJAX,AJAX와 함께 CSRF 보호 사용
"While the above method can be used for AJAX POST requests, it has some inconveniences: you have to remember to pass the CSRF token in as POST data with every POST request. For this reason, there is an alternative method: on each XMLHttpRequest, set a custom ``X-CSRFToken`` header (as specified by the :setting:`CSRF_HEADER_NAME` setting) to the value of the CSRF token. This is often easier because many JavaScript frameworks provide hooks that allow headers to be set on every request.","위의 방법을 AJAX POST 요청에 사용할 수 있지만 몇 가지 불편한 점이 있습니다: 모든 POST 요청에 POST 데이터로 CSRF 토큰을 전달해야 합니다. 이러한 불편함 때문에, 다른 대체 방법이 있습니다: 각 XMLHttpRequest에서 사용자 지정 ``X-CSRFToken`` 헤더(:setting:`CSRF_HEADER_NAME` 설정에 지정된 대로)를 CSRF 토큰 값으로 설정합니다. 많은 JavaScript 프레임워크가 모든 요청에 대해 헤더를 설정할 수 있도록 하는 후크를 제공하기 때문에 이 방식이 종종 더 쉽습니다."
"First, you must get the CSRF token. How to do that depends on whether or not the :setting:`CSRF_USE_SESSIONS` and :setting:`CSRF_COOKIE_HTTPONLY` settings are enabled.","먼저, CSRF 토큰을 받아야 합니다. 그 방법은 :setting:`CSRF_USE_SESSIONS` 및 :setting:`CSRF_COOKIE_HTTPONLY` 설정이 활성화되어 있는지 여부에 따라 다릅니다."
Acquiring the token if :setting:`CSRF_USE_SESSIONS` and :setting:`CSRF_COOKIE_HTTPONLY` are ``False``,:setting:`CSRF_USE_SESSIONS` 및 :setting:`CSRF_COOKIE_HTTPONLY`가 ``False``인 경우 토큰 획득
"The recommended source for the token is the ``csrftoken`` cookie, which will be set if you've enabled CSRF protection for your views as outlined above.","토큰의 권장 원본은 ``csrftoken`` 쿠키이며, 이는 위에서 설명한 대로 뷰에 대해 CSRF 보호를 활성화한 경우 자동으로 설정됩니다."
"The CSRF token cookie is named ``csrftoken`` by default, but you can control the cookie name via the :setting:`CSRF_COOKIE_NAME` setting.",CSRF 토큰 쿠키의 이름은 기본적으로 ``csrftoken``이지만 :setting:`CSRF_COOKIE_NAME` 설정을 통해 쿠키 이름을 설정할 수 있습니다.
You can acquire the token like this:,다음과 같이 토큰을 획득할 수 있습니다:
The above code could be simplified by using the `JavaScript Cookie library <https://github.com/js-cookie/js-cookie/>`_ to replace ``getCookie``:,위의 코드는 ``getCookie``를 대체하기 위한 `JavaScript 쿠키 라이브러리 <https://github.com/js-cookie/js-cookie/>`_를 사용하여 단순화할 수 있습니다.
"The CSRF token is also present in the DOM in a masked form, but only if explicitly included using :ttag:`csrf_token` in a template. The cookie contains the canonical, unmasked token. The :class:`~django.middleware.csrf.CsrfViewMiddleware` will accept either. However, in order to protect against `BREACH`_ attacks, it's recommended to use a masked token.",CSRF 토큰은 템플릿에서 :ttag:`csrf_token`을 사용하여 명시적으로 include된 경우에만 DOM에도 마스크된 형태로 존재합니다. 쿠키에는 마스크되지 않은 표준 토큰이 포함되어 있습니다. :class:`~django.middleware.csrf.CsrfViewMiddleware`는 둘 중 하나를 수락합니다. 그러나 BREACH`_ 공격으로부터 보호하기 위해서는 마스킹된 토큰을 사용하는 것이 좋습니다.
"If your view is not rendering a template containing the :ttag:`csrf_token` template tag, Django might not set the CSRF token cookie. This is common in cases where forms are dynamically added to the page. To address this case, Django provides a view decorator which forces setting of the cookie: :func:`~django.views.decorators.csrf.ensure_csrf_cookie`.","만약 뷰가 :ttag:`csrf_token` 템플릿 태그가 포함된 템플릿을 렌더링하지 않는 경우, 장고는 CSRF 토큰 쿠키를 설정하지 않을 수 있습니다. 이는 양식이 페이지에 동적으로 추가되는 경우에는 일반적인 설정입니다. 이 경우, 장고는 쿠키 설정을 강제하는 뷰 데코레이터를 제공합니다: :func:`~django.views.decorators.csrf.ensure_csrf_cookie`."
Acquiring the token if :setting:`CSRF_USE_SESSIONS` or :setting:`CSRF_COOKIE_HTTPONLY` is ``True``,:setting:`CSRF_USE_SESSIONS` 또는 :setting:`CSRF_COOKIE_HTTPONLY`가 ``True``인 경우 토큰 획득
"If you activate :setting:`CSRF_USE_SESSIONS` or :setting:`CSRF_COOKIE_HTTPONLY`, you must include the CSRF token in your HTML and read the token from the DOM with JavaScript:",":setting:`CSRF_USE_SESSIONS` 또는 :setting:`CSRF_COOKIE_HTTPONLY`를 활성화하는 경우, HTML에 CSRF 토큰을 포함하고 JavaScript를 사용하여 DOM에서 토큰을 읽어야 합니다."
Setting the token on the AJAX request,AJAX 요청에 대한 토큰 설정
"Finally, you'll need to set the header on your AJAX request. Using the `fetch()`_ API:","마지막으로, AJAX 요청에 헤더를 설정해야 합니다. `fetch()`_ API 사용:"
Using CSRF protection in Jinja2 templates,Jinja2 템플릿에서 CSRF 보호 사용
Django's :class:`~django.template.backends.jinja2.Jinja2` template backend adds ``{{ csrf_input }}`` to the context of all templates which is equivalent to ``{% csrf_token %}`` in the Django template language. For example:,장고의 :class:`~django.template.backends.jinja2.Jinja2` 템플릿 백엔드는 장고의 템플릿 언어 내의 ``{% csrf_token %}``에 해당하는 모든 템플릿의 컨텍스트에 ``{{ csrf_input }}``를 추가합니다. 예를 들어:
Using the decorator method,데코레이터 메서드 사용
"Rather than adding ``CsrfViewMiddleware`` as a blanket protection, you can use the :func:`~django.views.decorators.csrf.csrf_protect` decorator, which has exactly the same functionality, on particular views that need the protection. It must be used **both** on views that insert the CSRF token in the output, and on those that accept the POST form data. (These are often the same view function, but not always).","``CsrfViewMiddleware``를 포괄적인 보호 기능으로 추가하는 대신 보호가 필요한 특정 뷰에 정확히 동일한 기능을 가진 :func:`~django.views.decorators.csrf.csrf_protect` 데코레이터를 사용할 수 있습니다. 이는 출력에 CSRF 토큰을 삽입하는 뷰와 POST 양식 데이터를 수락하는 뷰에서 **둘 다** 사용해야 합니다. (이 둘은 종종 동일한 뷰 함수이지만, 항상 그런 것은 아닙니다)."
"Use of the decorator by itself is **not recommended**, since if you forget to use it, you will have a security hole. The 'belt and braces' strategy of using both is fine, and will incur minimal overhead.","데코레이터를 그 자체로 사용하는 것은 **권장하지 않습니다**. 사용하는 것을 잊어버리면 보안 구멍이 생기기 때문입니다. 둘 다 사용하는 '벨트 및 버팀대' 전략은 괜찮으며, 이 경우 최소한의 오버헤드가 발생합니다."
Handling rejected requests,거부된 요청 처리
"By default, a '403 Forbidden' response is sent to the user if an incoming request fails the checks performed by ``CsrfViewMiddleware``. This should usually only be seen when there is a genuine Cross Site Request Forgery, or when, due to a programming error, the CSRF token has not been included with a POST form.","기본적으로, 들어오는 요청이 ``CsrfViewMiddleware``에서 수행한 검사에 실패하면 '403 Forbidden' 응답이 사용자에게 전송됩니다. 이것은 실제 Cross Site Request Forgery가 있거나, 프로그래밍 오류로 인해 CSRF 토큰이 POST 양식에 포함되지 않은 경우에만 전송되어야 합니다."
"The error page, however, is not very friendly, so you may want to provide your own view for handling this condition. To do this, set the :setting:`CSRF_FAILURE_VIEW` setting.","그러나 오류 페이지는 그다지 친숙하지 않으므로 이 조건을 처리하기 위한 고유한 뷰를 제공할 수 있습니다. 이렇게 하려면, :setting:`CSRF_FAILURE_VIEW`를 설정합니다."
CSRF failures are logged as warnings to the :ref:`django.security.csrf <django-security-logger>` logger.,CSRF 실패는 :ref:`django.security.csrf <django-security-logger>` 로거에 경고로 기록됩니다.
Using CSRF protection with caching,캐싱과 함께 CSRF 보호 사용
"If the :ttag:`csrf_token` template tag is used by a template (or the ``get_token`` function is called some other way), ``CsrfViewMiddleware`` will add a cookie and a ``Vary: Cookie`` header to the response. This means that the middleware will play well with the cache middleware if it is used as instructed (``UpdateCacheMiddleware`` goes before all other middleware).",":ttag:`csrf_token` 템플릿 태그가 템플릿에서 사용되는 경우(또는 ``get_token`` 함수가 다른 방식으로 호출되는 경우), ``CsrfViewMiddleware``는 쿠키와 ``Vary: Cookie`` 헤더를 응답에 추가합니다. 이것은 미들웨어가 지시된 대로 잘 사용된다면 캐시 미들웨어와 함께 잘 작동함을 의미합니다(``UpdateCacheMiddleware``는 다른 모든 미들웨어보다 먼저 실행됨)."
"However, if you use cache decorators on individual views, the CSRF middleware will not yet have been able to set the Vary header or the CSRF cookie, and the response will be cached without either one. In this case, on any views that will require a CSRF token to be inserted you should use the :func:`django.views.decorators.csrf.csrf_protect` decorator first::","그러나 개별 뷰에서 캐시 데코레이터를 사용하는 경우, CSRF 미들웨어는 아직 Vary 헤더 또는 CSRF 쿠키를 설정할 수 없으며 응답은 둘 중 하나만 캐시됩니다. 이 경우 CSRF 토큰을 삽입해야 하는 모든 뷰에서 :func:`django.views.decorators.csrf.csrf_protect` 데코레이터를 먼저 사용해야 합니다."
"If you are using class-based views, you can refer to :ref:`Decorating class-based views<decorating-class-based-views>`.","클래스 기반 보기를 사용하는 경우, :ref:`클래스 기반 뷰 꾸미기<decorating-class-based-views>`를 참조할 수 있습니다."
Testing and CSRF protection,테스트 및 CSRF 보호
"The ``CsrfViewMiddleware`` will usually be a big hindrance to testing view functions, due to the need for the CSRF token which must be sent with every POST request. For this reason, Django's HTTP client for tests has been modified to set a flag on requests which relaxes the middleware and the ``csrf_protect`` decorator so that they no longer rejects requests. In every other respect (e.g. sending cookies etc.), they behave the same.","``CsrfViewMiddleware``는 일반적으로 모든 POST 요청과 함께 보내야 하는 CSRF 토큰이 필요하기 때문에, 뷰 기능을 테스트하는 데 큰 방해가 됩니다. 이러한 이유로 장고의 테스트용 HTTP 클라이언트는 미들웨어와 ``csrf_protect`` 데코레이터를 완화하는 요청에 플래그를 설정하여 더 이상 요청을 거부하지 않도록 수정되어 있습니다. 다른 모든 측면(예: 쿠키 보내기 등)에서는 동일하게 동작합니다."
"If, for some reason, you *want* the test client to perform CSRF checks, you can create an instance of the test client that enforces CSRF checks::","어떤 이유로 테스트 클라이언트가 CSRF 검사를 수행하도록 *원하는 경우*, CSRF 검사를 시행하는 테스트 클라이언트의 인스턴스를 생성할 수 있습니다."
Edge cases,경계 조건들
Certain views can have unusual requirements that mean they don't fit the normal pattern envisaged here. A number of utilities can be useful in these situations. The scenarios they might be needed in are described in the following section.,특정 뷰에는 여기에서 예상하고 있는 일반적인 패턴에 맞지 않는 비정상적인 요구 사항이 있을 수 있습니다. 이러한 상황에는 여러 유틸리티를 사용할 수 있습니다. 필요할 수 있는 시나리오는 다음 섹션에 설명되어 있습니다.
Disabling CSRF protection for just a few views,일부 뷰에 대한 CSRF 보호 비활성화
"Most views requires CSRF protection, but a few do not.",대부분의 뷰에는 CSRF 보호가 필요하지만 일부는 그렇지 않습니다.
"Solution: rather than disabling the middleware and applying ``csrf_protect`` to all the views that need it, enable the middleware and use :func:`~django.views.decorators.csrf.csrf_exempt`.","해결책: 미들웨어를 비활성화하고 필요한 모든 보기에 ``csrf_protect``를 적용하는 대신, 미들웨어를 활성화하고 :func:`~django.views.decorators.csrf.csrf_exempt`를 사용하세요."
Setting the token when ``CsrfViewMiddleware.process_view()`` is not used,``CsrfViewMiddleware.process_view()``를 사용하지 않을 때 토큰 설정
"There are cases when ``CsrfViewMiddleware.process_view`` may not have run before your view is run - 404 and 500 handlers, for example - but you still need the CSRF token in a form.",404 및 500 핸들러와 같이 뷰가 실행되기 전에 ``CsrfViewMiddleware.process_view``가 실행되지 않는 경우들이 있습니다. 하지만 여전히 양식에는 CSRF 토큰이 필요합니다.
Solution: use :func:`~django.views.decorators.csrf.requires_csrf_token`,해결책: :func:`~django.views.decorators.csrf.requires_csrf_token`을 사용하세요.
Including the CSRF token in an unprotected view,보호되지 않은 뷰에 CSRF 토큰 include하기
"There may be some views that are unprotected and have been exempted by ``csrf_exempt``, but still need to include the CSRF token.","보호되지 않았거나 ``csrf_exempt``에 의해 면제되었지만, 여전히 CSRF 토큰을 포함해야 하는 일부 뷰가 있을 수 있습니다."
Solution: use :func:`~django.views.decorators.csrf.csrf_exempt` followed by :func:`~django.views.decorators.csrf.requires_csrf_token`. (i.e. ``requires_csrf_token`` should be the innermost decorator).,"해결책: :func:`~django.views.decorators.csrf.csrf_exempt` 다음에 :func:`~django.views.decorators.csrf.requires_csrf_token`을 사용하세요. (즉, ``requires_csrf_token``은 가장 안쪽 데코레이터여야 함)."
Protecting a view for only one path,하나의 경로에 대해서만 뷰 보호
"A view needs CSRF protection under one set of conditions only, and mustn't have it for the rest of the time.","한 가지 조건 세트에서만 CSRF 보호를 필요로 하며, 나머지 시간 동안에는 보호하지 않아야 하는 뷰."
"Solution: use :func:`~django.views.decorators.csrf.csrf_exempt` for the whole view function, and :func:`~django.views.decorators.csrf.csrf_protect` for the path within it that needs protection. Example::",솔루션: 전체 뷰 기능에는 :func:`~django.views.decorators.csrf.csrf_exempt`를 사용하고 보호가 필요한 경로에는 :func:`~django.views.decorators.csrf.csrf_protect`를 사용합니다. 예시::
Protecting a page that uses AJAX without an HTML form,HTML 양식 없이 AJAX를 사용하는 페이지 보호
"A page makes a POST request via AJAX, and the page does not have an HTML form with a :ttag:`csrf_token` that would cause the required CSRF cookie to be sent.","AJAX를 통해 POST 요청을 하며, 필수 CSRF 쿠키가 전송되도록 하는 :ttag:`csrf_token`이 포함된 HTML 양식이 없는 페이지."
Solution: use :func:`~django.views.decorators.csrf.ensure_csrf_cookie` on the view that sends the page.,솔루션: 페이지를 보내는 뷰에서 :func:`~django.views.decorators.csrf.ensure_csrf_cookie`를 사용하세요.
CSRF protection in reusable applications,재사용 가능한 애플리케이션에서 CSRF 보호
"Because it is possible for the developer to turn off the ``CsrfViewMiddleware``, all relevant views in contrib apps use the ``csrf_protect`` decorator to ensure the security of these applications against CSRF. It is recommended that the developers of other reusable apps that want the same guarantees also use the ``csrf_protect`` decorator on their views.",개발자가 ``CsrfViewMiddleware``를 끌 수 있기 때문에 contrib apps와 관련된 모든 뷰들은 CSRF에 대한 이러한 애플리케이션의 보안을 보장하기 위해 ``csrf_protect`` 데코레이터를 사용합니다. 동일한 보장을 원하는 다른 재사용 가능한 앱의 개발자도 자신의 뷰에 ``csrf_protect`` 데코레이터를 사용하는 것이 좋습니다.
How to write a custom storage class,커스텀 스토리지 클래스를 작성하는 방법
How to write custom lookups,사용자 정의 lookup을 작성하는 방법
By using ``Transform`` instead of ``Lookup`` it means we are able to chain further lookups afterward. So ``Experiment.objects.filter(change__abs__lt=27)`` will generate the following SQL:,``Lookup`` 대신 ``Transform``을 사용하면 나중에 추가 lookup을 연결할 수 있습니다. 따라서 ``Experiment.objects.filter(change__abs__lt=27)``는 다음 SQL을 생성합니다:
"A list or tuple of tags, e.g. ``[Tags.staticfiles, Tags.models]``. System checks :ref:`registered in the chosen tags <registering-labeling-checks>` will be checked for errors prior to executing the command. The value ``'__all__'`` can be used to specify that all system checks should be performed. Default value is ``'__all__'``.","태그 리스트나 튜플, 예: ``[Tags.staticfiles, Tags.models]``. 시스템 검사 :ref:`선택한 태그<registering-labeling-checks>에 등록됨`은 명령을 실행하기 전에 오류를 검사합니다. 값 ``'__all__'``은 모든 시스템 검사가 수행되어야 함을 지정하는 데 사용할 수 있습니다. 기본값은 ``'__all__'``입니다."
The default command options to suppress in the help output. This should be a set of option names (e.g. ``'--verbosity'``). The default values for the suppressed options are still passed.,도움말 출력에서 억제할 기본 명령 옵션입니다. 이것은 옵션 이름의 집합이어야 합니다(예: ``'--verbosity'``). 억제된 옵션의 기본값은 여전히 전달됩니다.
"Tries to execute this command, performing system checks if needed (as controlled by the :attr:`requires_system_checks` attribute). If the command raises a :exc:`CommandError`, it's intercepted and printed to ``stderr``.","필요한 경우 시스템 검사를 수행하여 이 명령을 실행하시오( :attr:'requires_system_checks' 속성에 의해 제어됨). 커맨드가 :exc:`CommandError` 을 보여주는 경우, 중간에 가로채져 ``stderr``에 출력될 것입니다."
Uses the system check framework to inspect the entire Django project for potential problems. Serious problems are raised as a :exc:`CommandError`; warnings are output to ``stderr``; minor notifications are output to ``stdout``.,시스템 검사 프레임워크를 사용하여 전체 장고 프로젝트에 잠재적인 문제가 있는지 검사합니다. 심각한 문제는 다음과 같이 제기됩니다:exc:`CommandError`;경고는 ``stderr``로 출력되고 경미한 알림은 ``stdout``으로 출력됩니다.
"If this exception is raised during the execution of a management command from a command line console, it will be caught and turned into a nicely-printed error message to the appropriate output stream (i.e., ``stderr``); as a result, raising this exception (with a sensible description of the error) is the preferred way to indicate that something has gone wrong in the execution of a command. It accepts the optional ``returncode`` argument to customize the exit status for the management command to exit with, using :func:`sys.exit`.","명령줄 콘솔에서 관리 명령을 실행하는 동안 이 예외가 발생하면 해당 명령이 캡처되어 적절한 출력 스트림(예, ``stderr``)으로 인쇄된 오류 메시지로 전환됩니다. 따라서 오류에 대한 적절한 설명을 통해 이 예외를 발생시키는 것이 좋습니다.명령을 잘못 실행하다 그것은 :func:'sys.exit'을 사용하여 관리 명령의 종료 상태를 사용자 정의하기 위한 선택적인 ``returncode`` 주장을 수용한다."
How to create custom model fields,사용자 지정 모델 필드를 만드는 방법
"For our ``Hand`` example, we could convert the card data to a string of 104 characters by concatenating all the cards together in a predetermined order -- say, all the *north* cards first, then the *east*, *south* and *west* cards. So ``Hand`` objects can be saved to text or character columns in the database.","우리의 ""Hand"" 예에서는 모든 카드를 미리 정해진 순서대로 연결함으로써 104자 문자열로 카드 데이터를 변환할 수 있습니다. 예를 들어 모든 *북* 카드, 그 다음 *동*, *남* 및 *서* 카드). 따라서 ""Hand"" 개체를 데이터베이스의 텍스트 또는 문자 열에 저장할 수 있습니다."
"The counterpoint to writing your ``__init__()`` method is writing the :meth:`~.Field.deconstruct` method. It's used during :doc:`model migrations </topics/migrations>` to tell Django how to take an instance of your new field and reduce it to a serialized form - in particular, what arguments to pass to ``__init__()`` to recreate it.","당신의 ``__init__()"" 방식을 쓰는 것의 대척점은 :meth:""를 쓰는 것이다.Field.deconstruction' 메서드입니다. 그것은 :doc:'model migration </topics/migrations>'에서 Django에게 당신의 새로운 필드의 예를 들어 그것을 직렬화된 형태로 줄이는 방법, 특히 그것을 재생성하기 위해 ""_init_()""로 전달할 인수들을 말한다."
Field attributes not affecting database column definition,데이터베이스 열 정의에 영향을 주지 않는 필드 속성
You can override ``Field.non_db_attrs`` to customize attributes of a field that don't affect a column definition. It's used during model migrations to detect no-op ``AlterField`` operations.,``Field.non_db_attrs``를 재정의하여 열 정의에 영향을 미치지 않는 필드의 속성을 사용자 정의할 수 있습니다. no-op ``AlterField`` 작업을 감지하기 위해 모델 마이그레이션 중에 사용됩니다.
"If you aim to build a database-agnostic application, you should account for differences in database column types. For example, the date/time column type in PostgreSQL is called ``timestamp``, while the same column in MySQL is called ``datetime``. You can handle this in a :meth:`~Field.db_type` method by checking the ``connection.vendor`` attribute. Current built-in vendor names are: ``sqlite``, ``postgresql``, ``mysql``, and ``oracle``.","데이터베이스에 구애받지 않는 애플리케이션을 구축하려는 경우 데이터베이스 열 유형의 차이를 고려해야 합니다. 예를 들어 PostgreSQL의 날짜/시간 열 유형은 ``timestamp``라고 하는 반면 MySQL의 동일한 열 유형은 ``datetime``입니다. ``connection.vendor`` 속성을 확인하여 ~Field.db_type` 메서드에서 이를 처리할 수 있습니다. 현재 빌트인 벤더 이름은 ``sqlite``, ``postgresql``, ``mysql`` 및 ``oracle``입니다."
"In our ``HandField`` class, we're storing the data as a ``VARCHAR`` field in the database, so we need to be able to process strings and ``None`` in the ``from_db_value()``. In ``to_python()``, we need to also handle ``Hand`` instances::",``HandField`` 클래스에서 데이터를 데이터베이스에 ``VARCHAR`` 필드로 저장하므로 ``from_db_value()``에서 문자열 및 ``None``을 처리할 수 있어야 합니다. ``to_python()``에서 ``Hand`` 인스턴스도 처리해야 합니다::
How to implement a custom template backend,커스텀 템플릿 백엔드를 구현하는 방법
How to create custom template tags and filters,커스텀 템플릿 태그 및 필터를 만드는 방법
"For a ton of examples, read the source code for Django's default filters and tags. They're in :source:`django/template/defaultfilters.py` and :source:`django/template/defaulttags.py`, respectively.",수많은 예제를 보려면 Django의 기본 필터 및 태그에 대한 소스 코드를 읽으십시오. 그것들은 각각 :source:`django/template/defaultfilters.py`와 :source:`django/template/defaulttags.py`에 있습니다.
"In development mode, you can add ``--reload`` to cause the server to reload any time a file is changed on disk.",개발 모드에서는 ``--reload``를 추가하여 디스크에서 파일이 변경될 때마다 서버가 다시 로드되도록 할 수 있습니다.
Deploying Django using Uvicorn and Gunicorn,Uvicorn 및 Gunicorn을 사용하여 Django 배포
Gunicorn_ is a robust web server that implements process monitoring and automatic restarts. This can be useful when running Uvicorn in a production environment.,Gunicorn_은 프로세스 모니터링 및 자동 재시작을 구현하는 강력한 웹 서버입니다. 이는 프로덕션 환경에서 Uvicorn을 실행할 때 유용할 수 있습니다.
"To install Uvicorn and Gunicorn, use the following::",Uvicorn 및 Gunicorn을 설치하려면 다음을 사용하십시오::
Then start Gunicorn using the Uvicorn worker class like this::,이후 다음과 같이 Uvicorn worker 클래스를 사용하여 Gunicorn을 시작합니다::
"The internet is a hostile environment. Before deploying your Django project, you should take some time to review your settings, with security, performance, and operations in mind.","인터넷은 위험한 환경입니다. Django 프로젝트를 배포하기 전에 보안, 성능 및 작업을 염두에 두고 설정을 검토해야 합니다."
"If rotating secret keys, you may use :setting:`SECRET_KEY_FALLBACKS`::",비밀 키를 순환하는 경우 :setting:`SECRET_KEY_FALLBACKS`::를 사용할 수 있습니다.
Ensure that old secret keys are removed from ``SECRET_KEY_FALLBACKS`` in a timely manner.,적절한 때에 ``SECRET_KEY_FALLBACKS``에서 오래된 비밀 키가 제거되었는지 확인하십시오.
The ``SECRET_KEY_FALLBACKS`` setting was added to support rotating secret keys.,비밀 키 순환을 지원하기 위해 ``SECRET_KEY_FALLBACKS`` 설정이 추가되었습니다.
"You should also configure the web server that sits in front of Django to validate the host. It should respond with a static error page or ignore requests for incorrect hosts instead of forwarding the request to Django. This way you'll avoid spurious errors in your Django logs (or emails if you have error reporting configured that way). For example, on nginx you might set up a default server to return ""444 No Response"" on an unrecognized host:","또한 호스트를 검증하기 위해 Django 앞에 있는 웹 서버를 구성해야 합니다. 정적 오류 페이지로 응답하거나 Django에 요청을 전달하는 대신 잘못된 호스트에 대한 요청을 무시해야 합니다. 이렇게 하면 Django 로그(또는 그런 방식으로 구성된 오류 보고가 있는 경우 이메일)에서 가짜 오류를 피할 수 있습니다. 예를 들어 nginx에서 인식할 수 없는 호스트에서 ""444 No Response""를 반환하도록 기본 서버를 설정할 수 있습니다."
"Enabling the cached template loader often improves performance drastically, as it avoids compiling each template every time it needs to be rendered. When :setting:`DEBUG = False <DEBUG>`, the cached template loader is enabled automatically. See :class:`django.template.loaders.cached.Loader` for more information.",캐시된 템플릿 로더를 활성화하면 각 템플릿을 렌더링해야 할 때마다 컴파일하지 않아도 되므로 성능이 크게 향상되는 경우가 많습니다. 설정:`DEBUG = False <DEBUG>`인 경우 캐시된 템플릿 로더가 자동으로 활성화됩니다. 자세한 내용은 :class:`django.template.loaders.cached.Loader`를 참조하십시오.
"Django includes default views and templates for several HTTP error codes. You may want to override the default templates by creating the following templates in your root template directory: ``404.html``, ``500.html``, ``403.html``, and ``400.html``. The :ref:`default error views <error-views>` that use these templates should suffice for 99% of web applications, but you can :ref:`customize them <customizing-error-views>` as well.","Django에는 여러 HTTP 오류 코드에 대한 기본 보기 및 템플릿이 포함되어 있습니다. 루트 템플릿 디렉토리에 ``404.html``, ``500.html``, ``403.html`` 및 ``400.html` 템플릿을 생성하여 기본 템플릿을 재정의할 수 있습니다. 99%의 웹 응용 프로그램에는 이러한 템플릿을 사용하는 :ref:`기본 오류 뷰 <error-views>`가 충분하지만, :ref:`사용자 정의 <customizing-error-views>`할 수도 있습니다."
How to deploy Django,장고를 배포하는 방법
"Django is full of shortcuts to make web developers' lives easier, but all those tools are of no use if you can't easily deploy your sites. Since Django's inception, ease of deployment has been a major goal.","Django는 웹 개발자의 생활을 더 쉽게 만들 수 있는 지름길로 가득 차 있지만, 사이트를 쉽게 배치할 수 없다면 이러한 도구들은 아무 소용이 없습니다. django의 설립 이후, 배치의 용이성이 주요 목표였다."
"`WSGI`_ is the main Python standard for communicating between web servers and applications, but it only supports synchronous code.",WSGI는 웹 서버와 애플리케이션 간의 통신을 위한 주요 파이썬 표준이지만 동기식 코드만 지원한다.
How to authenticate against Django's user database from Apache,Apache에서 Django의 사용자 데이터베이스에 대해 인증하는 방법
Make sure that mod_wsgi is installed and activated and that you have followed the steps to set up :doc:`Apache with mod_wsgi </howto/deployment/wsgi/modwsgi>`.,"mod_wsgi가 설치 및 활성화되었는지 확인하고, 다음 단계를 따라 설정했는지 확인합니다:doc:`mod_wsgi가 있는 아파치 </howto/deployment/wsgi/modwsgi>.`"
"If you get a ``UnicodeEncodeError`` when uploading or writing files with file names or content that contains non-ASCII characters, make sure Apache is configured to support UTF-8 encoding::",ASCII가 아닌 문자가 포함된 파일 이름이나 콘텐츠로 파일을 업로드하거나 쓸 때 ``UnicodeEncodeError``가 발생하면 Apache가 UTF-8 인코딩을 지원하도록 구성되었는지 확인하세요.
"Alternatively, if you are :ref:`using mod_wsgi daemon mode<daemon-mode>` you can add ``lang`` and ``locale`` options to the ``WSGIDaemonProcess`` directive::",대신 :ref:`mod_wsgi 데몬 모드를 사용하고 있다면<daemon-mode>` ``lang`` 및 ``locale`` 옵션을 ``WSGIDaemonProcess`` 지시문에 추가할 수 있습니다::
Django doesn't serve files itself; it leaves that job to whichever web server you choose.,Django는 파일 자체를 서비스하지 않습니다; Django는 선택한 웹 서버에 해당 작업을 맡깁니다.
"We recommend using a separate web server -- i.e., one that's not also running Django -- for serving media. Here are some good choices:",미디어 서비스를 위해 Django를 실행하지도 않는 별도의 웹 서버를 사용하는 것이 좋습니다. 몇 가지 좋은 선택은 다음과 같습니다.
"When :mod:`django.contrib.staticfiles` is in :setting:`INSTALLED_APPS`, the Django development server automatically serves the static files of the admin app (and any other installed apps). This is however not the case when you use any other server arrangement. You're responsible for setting up Apache, or whichever web server you're using, to serve the admin files.",":모드:`django.contrib.staticfiles의:에 있:`INSTALLED_APPS`, 장고 개발 서버는 자동으로는 관리 앱(그리고 다른 설치된 apps)의 정적 파일을 제공한다. 이것은 하지만 사실이 아닐 때는 다른 서버 배열을 사용한다. 당신은 아파치를 설정하고, 아니면,는 관리 파일을 제공하는 중 웹 서버를 사용하는 책임이 있다."
"We **strongly** recommend using :mod:`django.contrib.staticfiles` to handle the admin files (along with a web server as outlined in the previous section; this means using the :djadmin:`collectstatic` management command to collect the static files in :setting:`STATIC_ROOT`, and then configuring your web server to serve :setting:`STATIC_ROOT` at :setting:`STATIC_URL`), but here are three other approaches:","에서는 관리자 파일(앞부분에서 설명한 웹 서버와 함께):mod:'django.contrib.static files'를 사용하여 정적 파일을 :seting:'에서 수집하도록 강력 권장합니다.STATIC_ROOT'을 선택한 다음 웹 서버가 서비스하도록 구성합니다. 설정:'STATIC_ROOT' at : setting:'STATIC_URL)'), 그러나 다음은 세 가지 다른 접근법이다."
"uWSGI operates on a client-server model. Your web server (e.g., nginx, Apache) communicates with a ``django-uwsgi`` ""worker"" process to serve dynamic content.","uWSGI는 클라이언트-서버 모델에서 작동합니다. 웹 서버(예: nginx, Apache)는 동적 컨텐츠를 제공하기 위해 ``django-uwsgi"" 프로세스로 통신합니다."
How to manage error reporting,오류 보고를 관리하는 방법
"If those conditions are met, Django will email the users listed in the :setting:`MANAGERS` setting whenever your code raises a 404 and the request has a referer. It doesn't bother to email for 404s that don't have a referer -- those are usually people typing in broken URLs or broken web bots. It also ignores 404s when the referer is equal to the requested URL, since this behavior is from broken web bots too.",이러한 조건이 충족되면 Django는 :seting에 나열된 사용자에게 e-메일을 보냅니다.당신의 코드가 404를 올리고 요청에 레퍼러가 있을 때마다 '매니저즈'가 설정된다. 참조자가 없는 404대에게는 이메일로 보내는 것이 귀찮지 않습니다. 대개는 고장난 URL이나 고장난 웹 봇을 타이핑하는 사람들이죠. 또한 레퍼러가 요청한 URL과 동일한 경우 404초도 무시합니다. 이 동작도 손상된 웹 봇에서 발생되기 때문입니다.
":class:`~django.middleware.common.BrokenLinkEmailsMiddleware` must appear before other middleware that intercepts 404 errors, such as :class:`~django.middleware.locale.LocaleMiddleware` or :class:`~django.contrib.flatpages.middleware.FlatpageFallbackMiddleware`. Put it toward the top of your :setting:`MIDDLEWARE` setting.",:class:`~django.middleware.common.BrokenLinkEmailsMiddleware`는 404 오류를 가로채는 다른 미들웨어(예: :class:`~django.middleware.locale.LocaleMiddleware` 또는 :class:`~django.contrib.flatpages) 앞에 나타나야 합니다. :setting:`MIDDLEWARE` 설정의 맨 위에 놓으십시오.
"Filtering sensitive data is a hard problem, and it's nearly impossible to guarantee that sensitive data won't leak into an error report. Therefore, error reports should only be available to trusted team members and you should avoid transmitting error reports unencrypted over the internet (such as through email).","중요한 데이터를 필터링하는 것은 어려운 문제이며 중요한 데이터가 오류 보고서에 유출되지 않도록 보장하는 것은 거의 불가능합니다. 따라서 오류 보고서는 신뢰할 수 있는 팀 구성원만 사용할 수 있어야 하며, 전자 메일 등의 인터넷을 통해 암호화되지 않은 오류 보고서를 전송하지 않아야 합니다."
Property that returns a :class:`pathlib.Path` representing the absolute filesystem path to a template for rendering the HTML representation of the exception. Defaults to the Django provided template.,예외의 HTML 표현을 렌더링하기 위한 템플릿에 대한 절대 파일 시스템 경로를 나타내는 클래스:`pathlib.Path`를 반환하는 property입니다. Django 제공 템플릿의 기본값입니다.
Property that returns a :class:`pathlib.Path` representing the absolute filesystem path to a template for rendering the plain-text representation of the exception. Defaults to the Django provided template.,예외의 일반 텍스트 표현을 렌더링하기 위한 템플릿에 대한 절대 파일 시스템 경로를 나타내는 클래스:`pathlib.Path`를 반환하는 property입니다. Django 제공 템플릿의 기본값입니다.
How to provide initial data for models,모델에 초기 데이터를 제공하는 방법
It's sometimes useful to prepopulate your database with hard-coded data when you're first setting up an app. You can provide initial data with migrations or fixtures.,앱을 처음 설정할 때 하드 코딩된 데이터로 데이터베이스를 미리 채우는 것이 때때로 유용합니다. 마이그레이션 또는 고정 장치와 함께 초기 데이터를 제공할 수 있습니다.
"You can load data by calling :djadmin:`manage.py loaddata <loaddata>` ``<fixturename>``, where ``<fixturename>`` is the name of the fixture file you've created. Each time you run :djadmin:`loaddata`, the data will be read from the fixture and reloaded into the database. Note this means that if you change one of the rows created by a fixture and then run :djadmin:`loaddata` again, you'll wipe out any changes you've made.",":djadmin:'manage.py loaddata <loaddata>` ``<fixturename>``를 호출하여 데이터를 로드할 수 있습니다. ``<fixturename>``는 당신이 만든 fixture 파일의 이름입니다. :djadmin:`loaddata`를 실행할 때마다 데이터는 고정장치에서 읽혀져 데이터베이스에 다시 로드됩니다. 이는 고정 장치에 의해 생성된 행 중 하나를 변경한 후 :djadmin:`loaddata`를 다시 실행하는 경우, 변경 내용이 모두 지워진다는 의미입니다."
How to integrate Django with a legacy database,Django를 레거시 데이터베이스와 통합하는 방법
How to configure and use logging,로깅 구성 및 사용 방법
:ref:`Django logging reference <logging-ref>`,:ref:`Django 로깅 참조 <logging-ref>`
:ref:`Django logging overview <logging-explanation>`,:ref:`Django 로깅 개요 <logging-explanation>`
Django provides a working :ref:`default logging configuration <default-logging-configuration>` that is readily extended.,Django는 쉽게 확장할 수 있는 :ref:`기본 로깅 구성 <default-logging-configuration>`을 제공합니다.
Make a basic logging call,기본 로깅 호출하기
"To send a log message from within your code, you place a logging call into it.",코드 내에서 로그 메시지를 보내려면 로깅 호출을 입력합니다.
Don't be tempted to use logging calls in ``settings.py``.,``settings.py``에서 로깅 호출을 사용하고 싶은 유혹에 빠지지 마십시오.
"The way that Django logging is configured as part of the ``setup()`` function means that logging calls placed in ``settings.py`` may not work as expected, because *logging will not be set up at that point*. To explore logging, use a view function as suggested in the example below.",Django 로깅을 ``setup()`` 함수의 일부로 구성하면 ``settings.py``에 있는 로깅 호출이 예상대로 작동하지 않을 수 있습니다. 왜냐하면 *로깅이 그 시점에서 설정되지 않기 때문입니다*. 로깅을 탐색하려면 아래 예에서 제안된 뷰 함수를 사용하십시오.
"First, import the Python logging library, and then obtain a logger instance with :py:func:`logging.getLogger`. Provide the ``getLogger()`` method with a name to identify it and the records it emits. A good option is to use ``__name__`` (see :ref:`naming-loggers` below for more on this) which will provide the name of the current Python module as a dotted path::","먼저 Python 로깅 라이브러리를 import한 다음, :py:func:`logging.getLogger`를 사용하여 로거 인스턴스를 가져옵니다. ``getLogger()`` 메서드에 이를 식별할 수 있는 이름과 생성하는 레코드를 제공하십시오. 좋은 옵션은 ``__name__``(자세한 내용은 아래의 :ref:`naming-loggers` 참조)을 사용하는 것입니다. 그러면 현재 파이썬 모듈의 이름이 점으로 구분된 경로로 제공됩니다::"
It's a good convention to perform this declaration at module level.,모듈 수준에서 이 선언을 수행하는 것이 좋습니다.
"And then in a function, for example in a view, send a record to the logger::",그런 다음 함수 안(예: 뷰 안)에서 로거에 레코드를 보냅니다::
"When this code is executed, a :py:class:`~logging.LogRecord` containing that message will be sent to the logger. If you're using Django's default logging configuration, the message will appear in the console.",이 코드가 실행되면 해당 메시지가 포함된 :py:class:`~logging.LogRecord`가 로거로 전송됩니다. Django의 기본 로깅 구성을 사용하는 경우 메시지가 콘솔에 나타납니다.
"The ``WARNING`` level used in the example above is one of several :ref:`logging severity levels <topic-logging-parts-loggers>`: ``DEBUG``, ``INFO``, ``WARNING``, ``ERROR``, ``CRITICAL``. So, another example might be::","위의 예에서 사용된 ``WARNING`` 수준은 여러 :ref:`로깅 심각도 수준들 <topic-logging-parts-loggers>`중 하나입니다: ``DEBUG``, ``INFO``, ``WARNING``, ``ERROR``, ` '중요'. 따라서 다른 예는 다음과 같습니다::"
Records with a level lower than ``WARNING`` will not appear in the console by default. Changing this behavior requires additional configuration.,``WARNING``보다 낮은 수준의 레코드는 기본적으로 콘솔에 나타나지 않습니다. 이 동작을 변경하려면 추가 구성이 필요합니다.
Customize logging configuration,로깅 구성 사용자 정의
"Although Django's logging configuration works out of the box, you can control exactly how your logs are sent to various destinations - to log files, external services, email and so on - with some additional configuration.","Django의 로깅 구성은 별 다른 구성 없이도 작동하지만, 몇 가지 추가 구성을 통해 로그가 다양한 대상(로그 파일, 외부 서비스, 이메일 등)으로 전송되는 방식을 정확하게 제어할 수 있습니다."
You can configure:,다음을 설정할 수 있습니다:
"logger mappings, to determine which records are sent to which handlers",어떤 레코드를 어떤 핸들러로 보낼지 결정하는 로거 매핑
"handlers, to determine what they do with the records they receive",받은 레코드로 무엇을 할지 결정하는 핸들러
"filters, to provide additional control over the transfer of records, and even modify records in-place",레코드 전송에 대한 추가 제어를 제공하고 레코드를 바로 수정할 수 있는 필터
"formatters, to convert :class:`~logging.LogRecord` objects to a string or other form for consumption by human beings or another system",:class:`~logging.LogRecord` 객체를 사람이나 다른 시스템에서 사용할 문자열이나 다른 형식으로 변환하는 포맷터
"There are various ways of configuring logging. In Django, the :setting:`LOGGING` setting is most commonly used. The setting uses the :ref:`dictConfig format <logging-config-dictschema>`, and extends the :ref:`default logging configuration <default-logging-definition>`.",로깅 구성에는 다양한 방법들이 있습니다. Django에서는 :setting:`LOGGING` 구성이 가장 일반적으로 사용됩니다. 이 구성은 :ref:`dictConfig 형식 <logging-config-dictschema>`을 사용하고 :ref:`기본 로깅 구성 <default-logging-definition>`을 확장합니다.
See :ref:`configuring-logging` for an explanation of how your custom settings are merged with Django's defaults.,사용자 지정 설정이 Django의 기본값과 병합되는 방법에 대한 설명은 :ref:`configuring-logging`을 참조하세요.
"See the :mod:`Python logging documentation <python:logging.config>` for details of other ways of configuring logging. For the sake of simplicity, this documentation will only consider configuration via the ``LOGGING`` setting.",로깅을 구성하는 다른 방법에 대한 자세한 내용은 mod:`Python 로깅 문서 <python:logging.config>`를 참조하세요. 단순화를 위해 이 문서에서는 ``LOGGING`` 설정을 통한 구성만 고려합니다.
Basic logging configuration,기본 로깅 구성
"When configuring logging, it makes sense to","로깅을 구성할 때, 다음을 수행하는 것이 좋습니다:"
Create a ``LOGGING`` dictionary,``LOGGING`` 사전 생성
In your ``settings.py``::,``settings.py``에서::
It nearly always makes sense to retain and extend the default logging configuration by setting ``disable_existing_loggers`` to ``False``.,``disable_existing_loggers``를 ``False``로 설정하여 기본 로깅 구성을 유지하고 확장하는 것이 거의 항상 좋습니다.
Configure a handler,핸들러 구성
"This example configures a single handler named ``file``, that uses Python's :class:`~logging.FileHandler` to save logs of level ``DEBUG`` and higher to the file ``general.log`` (at the project root):",이 예제는 Python의 :class:`~logging.FileHandler`를 사용하여 ``DEBUG`` 이상의 로그를 (프로젝트 루트에 있는) ``general.log`` 파일에 저장하는 ``file``이라는 단일 핸들러를 구성합니다:
"Different handler classes take different configuration options. For more information on available handler classes, see the :class:`~django.utils.log.AdminEmailHandler` provided by Django and the various :py:mod:`handler classes <logging.handlers>` provided by Python.",다른 핸들러 클래스는 다른 구성 옵션을 사용합니다. 사용 가능한 핸들러 클래스에 대한 자세한 내용은 Django에서 제공하는 클래스:`~django.utils.log.AdminEmailHandler` 및 Python에서 제공하는 다양한 핸들러 클래스 <logging.handlers>`를 참조하세요.
"Logging levels can also be set on the handlers (by default, they accept log messages of all levels). Using the example above, adding:",로깅 수준은 핸들러에서도 설정할 수 있습니다(기본적으로 모든 수준의 로그 메시지를 수락함). 위의 예를 사용하여 다음을 추가합니다:
would define a handler configuration that only accepts records of level ``DEBUG`` and higher.,``DEBUG`` 수준 이상의 레코드만 허용하는 핸들러 구성을 정의합니다.
Configure a logger mapping,로거 매핑 설정
"To send records to this handler, configure a logger mapping to use it for example:","이 핸들러로 레코드를 보내려면, 로거 매핑을 구성합니다. 예를 들면 다음과 같습니다:"
The mapping's name determines which log records it will process. This configuration (``''``) is *unnamed*. That means that it will process records from *all* loggers (see :ref:`naming-loggers` below on how to use the mapping name to determine the loggers for which it will process records).,"매핑의 이름은 처리할 로그 레코드를 결정합니다. 이 구성(``''``)은 *unnamed*입니다. 즉, *모든* 로거의 레코드를 처리한다는 의미입니다(레코드를 처리할 로거를 결정하기 위해 매핑 이름을 사용하는 방법은 아래의 :ref:`naming-loggers` 참조)."
It will forward messages of levels ``DEBUG`` and higher to the handler named ``file``.,``DEBUG`` 수준 이상의 메시지를 ``file``이라는 핸들러로 전달합니다.
"Note that a logger can forward messages to multiple handlers, so the relation between loggers and handlers is many-to-many.","로거는 여러 핸들러에 메시지를 전달할 수 있으므로, 로거와 핸들러 간의 관계는 many-to-many입니다."
If you execute::,만약 다음을 실행하는 경우::
"in your code, you will find that message in the file ``general.log`` in the root of the project.",코드에서 프로젝트 루트의 ``general.log`` 파일에서 해당 메시지를 찾을 수 있습니다.
Configure a formatter,포맷터 구성
"By default, the final log output contains the message part of each :class:`log record <logging.LogRecord>`. Use a formatter if you want to include additional data. First name and define your formatters - this example defines formatters named ``verbose`` and ``simple``:",기본적으로 최종 로그 출력에는 각 로그 레코드 <logging.LogRecord>`의 메시지 부분이 포함됩니다. 추가 데이터를 포함하려면 포맷터를 사용하십시오. 먼저 이름을 지정하고 포맷터를 정의합니다. 이 예에서는 ``verbose`` 및 ``simple``이라는 포맷터를 정의합니다:
The ``style`` keyword allows you to specify ``{`` for :meth:`str.format` or ``$`` for :class:`string.Template` formatting; the default is ``$``.,``style`` 키워드를 사용하면 :meth:`str.format`에 ``{``를 지정하거나 :class:`string.Template` 형식에 ``$``를 지정할 수 있습니다. 기본값은 ``$``입니다.
See :ref:`logrecord-attributes` for the :class:`~logging.LogRecord` attributes you can include.,include할 수 있는 :class:`~logging.LogRecord` 속성에 대해  :ref:`logrecord-attributes`를 참조하십시오.
"To apply a formatter to a handler, add a ``formatter`` entry to the handler's dictionary referring to the formatter by name, for example:","포맷터를 핸들러에 적용하려면, 이름으로 포맷터를 참조하는 핸들러의 사전에 ``formatter`` 항목을 추가하십시오. 예를 들면 다음과 같습니다:"
Use logger namespacing,로거 네임스페이싱 사용
The unnamed logging configuration ``''`` captures logs from any Python application. A named logging configuration will capture logs only from loggers with matching names.,명명되지 않은 로깅 설정 ``''``은 모든 Python 응용 프로그램에서 로그를 캡처합니다. 명명된 로깅 구성은 이름이 일치하는 로거에서만 로그를 캡처합니다.
The namespace of a logger instance is defined using :py:func:`~logging.getLogger`. For example in ``views.py`` of ``my_app``::,로거 인스턴스의 네임스페이스는 :py:func:`~logging.getLogger`를 사용하여 정의됩니다. 예를 들어 ``my_app``의 ``views.py``에서::
will create a logger in the ``my_app.views`` namespace. ``__name__`` allows you to organize log messages according to their provenance within your project's applications automatically. It also ensures that you will not experience name collisions.,는 ``my_app.views`` 네임스페이스에 로거를 생성합니다. ``__name__``을 사용하면 프로젝트의 애플리케이션 내에서 출처에 따라 로그 메시지를 자동으로 구성할 수 있습니다. 또한 이름 충돌이 발생하지 않도록 보장해줍니다.
A logger mapping named ``my_app.views`` will capture records from this logger:,``my_app.views``라는 로거 매핑은 이 로거에서 레코드를 캡처합니다:
"A logger mapping named ``my_app`` will be more permissive, capturing records from loggers anywhere within the ``my_app`` namespace (including ``my_app.views``, ``my_app.utils``, and so on):","``my_app``이라는 이름의 로거 매핑은 ``my_app`` 네임스페이스(``my_app.views``, ``my_app.utils`` 등 포함) 내의 모든 로거에서 레코드를 캡처하기 떄문에 더 관대합니다:"
You can also define logger namespacing explicitly::,다음과 같이 로거 네임스페이스를 명시적으로 정의할 수도 있습니다::
and set up logger mappings accordingly.,그리고 그에 따라 로거 매핑을 설정합니다.
Using logger hierarchies and propagation,로거 계층 및 전파 사용
"Logger naming is *hierarchical*. ``my_app`` is the parent of ``my_app.views``, which is the parent of ``my_app.views.private``. Unless specified otherwise, logger mappings will propagate the records they process to their parents - a record from a logger in the ``my_app.views.private`` namespace will be handled by a mapping for both ``my_app`` and ``my_app.views``.","로거 이름 지정은 *계층적*입니다. ``my_app``은 ``my_app.views.private``의 부모인 ``my_app.views``의 부모입니다. 달리 지정하지 않는 한, 로거 매핑은 처리하는 레코드를 부모에게 전파합니다. ``my_app.views.private`` 네임스페이스에 있는 로거의 레코드는 ``my_app`` 및 ``my_app.views`` 모두에 대한 매핑에 의해 처리됩니다."
"To manage this behavior, set the propagation key on the mappings you define::","이 동작을 관리하려면, 당신이 정의한 매핑에서 전파 키를 설정합니다."
"``propagate`` defaults to ``True``. In this example, the logs from ``my_app.views.private`` will not be handled by the parent, but logs from ``my_app.views`` will.",``propagate``의 기본값은 ``True``입니다. 이 예에서 ``my_app.views.private``의 로그는 상위에서 처리되지 않지만 ``my_app.views``의 로그는 처리됩니다.
Configure responsive logging,반응형 로깅 구성
"Logging is most useful when it contains as much information as possible, but not information that you don't need - and how much you need depends upon what you're doing. When you're debugging, you need a level of information that would be excessive and unhelpful if you had to deal with it in production.",로깅은 필요하지 않은 정보를 제외한 가능한 많은 정보를 포함할 때 가장 유용합니다. 필요한 정보의 양은 수행 중인 작업에 따라 다릅니다. 디버깅할 때는 프로덕션에서는 과도하고 도움이 되지 않는 수준의 정보가 필요합니다.
"You can configure logging to provide you with the level of detail you need, when you need it. Rather than manually change configuration to achieve this, a better way is to apply configuration automatically according to the environment.","필요할 때 필요한 세부 수준을 제공하도록 로깅을 구성할 수 있습니다. 이를 위해 수동으로 구성을 변경하는 것보다, 환경에 따라 자동으로 구성을 적용하는 것이 더 좋은 방법입니다."
"For example, you could set an environment variable ``DJANGO_LOG_LEVEL`` appropriately in your development and staging environments, and make use of it in a logger mapping thus::","예를 들어, 개발 및 스테이징 환경에서 ``DJANGO_LOG_LEVEL`` 환경 변수를 적절하게 설정하여 로거 매핑에서 사용할 수 있습니다::"
"\- so that unless the environment specifies a lower log level, this configuration will only forward records of severity ``WARNING`` and above to its handler.",\- 따라서 환경이 더 낮은 로그 수준을 지정하지 않는 한 이 구성은 ``WARNING`` 이상의 심각도를 가진 레코드만 핸들러로 전달합니다.
Other options in the configuration (such as the ``level`` or ``formatter`` option of handlers) can be similarly managed.,구성의 다른 옵션(예: 핸들러의 ``level`` 또는 ``formatter`` 옵션)도 유사하게 관리할 수 있습니다.
How to create CSV output,CSV로 출력하는 방법
How to create PDF files,PDF 파일을 만드는 방법
"When ``as_attachment=True`` is passed to ``FileResponse``, it sets the appropriate ``Content-Disposition`` header and that tells web browsers to pop-up a dialog box prompting/confirming how to handle the document even if a default is set on the machine. If the ``as_attachment`` parameter is omitted, browsers will handle the PDF using whatever program/plugin they've been configured to use for PDFs.","``as_attachment=True``가 ``FileResponse``에 전달되면, 적절한 ``Content-Disposition`` 헤더가 설정되어 이미 기본값이 설정된 기계의 웹브라우저에게 문서 처리 방법을 표시하고 확인하는 대화 상자를 팝업하도록 지시합니다. ``as_attachment`` 매개변수가 생략된 경우, 브라우저는 PDF에 사용하도록 구성된 프로그램/플러그인을 사용하여 PDF를 처리합니다."
How to override templates,템플릿 재정의 방법
``templates/admin/base_site.html``,``templates/admin/base_site.html``
How to deploy static files,정적 파일을 배포하는 방법
"Most larger Django sites use a separate web server -- i.e., one that's not also running Django -- for serving static files. This server often runs a different type of web server -- faster but less full-featured. Some common choices are:",대부분의 대형 Django 사이트에서는 정적 파일을 처리하기 위해 별도의 웹 서버(예: Django를 실행하지 않는 서버)를 사용합니다. 이 서버는 종종 다른 유형의 웹 서버를 실행하며 속도는 빠르지만 기능은 부족합니다. 일반적인 선택은 다음과 같습니다:
Another common tactic is to serve static files from a cloud storage provider like Amazon's S3 and/or a CDN (content delivery network). This lets you ignore the problems of serving static files and can often make for faster-loading web pages (especially when using a CDN).,또 다른 일반적인 방법은 Amazon의 S3 및/또는 CDN(컨텐츠 제공 네트워크)과 같은 클라우드 스토리지 공급업체의 정적 파일을 제공하는 것입니다. 이렇게 하면 정적 파일 서비스 문제를 무시할 수 있으며 웹 페이지를 더 빨리 로드할 수 있습니다(특히 CDN 사용 시).
"For example, if your :setting:`STATIC_URL` is defined as ``static/``, you can do this by adding the following snippet to your ``urls.py``::","예를 들어, :setting:`STATIC_URL`이 ``static/``로 정의된 경우, ``urls.py``에 다음 조각을 추가하여 이를 수행할 수 있습니다::"
This helper function works only in debug mode and only if the given prefix is local (e.g. ``static/``) and not a URL (e.g. ``http://static.example.com/``).,이 도우미 함수는 디버그 모드에서만 작동하며 주어진 접두사가 로컬(예: ``static/``)이고 URL(예: ``http://static.example.com/``)이 아닌 경우에만 작동합니다.
"Finally, static files are served via a wrapper at the WSGI application layer. As a consequence, static files requests do not pass through the normal :doc:`middleware chain </topics/http/middleware>`.",마지막으로 정적 파일은 WSGI 응용 프로그램 계층에서 래퍼를 통해 제공됩니다. 결과적으로 정적 파일 요청은 일반적인 :doc:`미들웨어 체인 </topics/http/middleware>`을 통과하지 않습니다.
"For example, if your :setting:`MEDIA_URL` is defined as ``media/``, you can do this by adding the following snippet to your :setting:`ROOT_URLCONF`::","예를 들어, :setting:`MEDIA_URL`이 ``media/``로 정의된 경우, 다음 조각을 :setting:`ROOT_URLCONF`에 추가하여 이를 수행할 수 있습니다::"
This helper function works only in debug mode and only if the given prefix is local (e.g. ``media/``) and not a URL (e.g. ``http://media.example.com/``).,이 도우미 함수는 디버그 모드에서만 작동하며 주어진 접두어가 로컬(예: ``media/``)이고 URL(예: ``http://media.example.com/``)이 아닌 경우에만 작동합니다.
How to upgrade Django to a newer version,Django를 최신 버전으로 업그레이드하는 방법
"Afterward, you should familiarize yourself with the changes that were made in the new Django version(s):",그런 다음 새 Django 버전에서 변경된 사항을 숙지해야 합니다:
"If you're not using the Django test runner, you may need to also ensure that any console output is not captured which would hide deprecation warnings. For example, if you use `pytest <https://docs.pytest.org/>`__:","Django 테스트 러너를 사용하지 않는 경우, 지원 중단 경고를 숨기는 콘솔 출력이 캡처되지 않았는지 확인해야 할 수도 있습니다. 예를 들어 `pytest <https://docs.pytest.org/>`__를 사용하는 경우:"
"To install Python on your machine go to https://www.python.org/downloads/. The website should offer you a download button for the latest Python version. Download the executable installer and run it. Check the boxes next to ""Install launcher for all users (recommended)"" then click ""Install Now"".","컴퓨터에 Python을 설치하려면 https://www.python.org/downloads/로 이동합니다. 웹 사이트에서 최신 Python 버전에 대한 다운로드 버튼을 제공해야 합니다. 실행 가능한 설치 프로그램을 다운로드하고 실행합니다. ""모든 사용자를 위한 런처 설치(권장)"" 옆의 확인란을 선택한 다음 ""지금 설치""를 클릭합니다."
"This will create a folder called 'project-name' if it does not already exist and set up the virtual environment. To activate the environment, run::",이렇게 하면 '프로젝트 이름' 폴더가 아직 없는 경우 해당 폴더가 생성되고 가상 환경이 설정됩니다. 환경을 활성화하려면 다음을 실행하십시오::
Colored terminal output,컬러 터미널 출력
"A quality-of-life feature adds colored (rather than monochrome) output to the terminal. In modern terminals this should work for both CMD and PowerShell. If for some reason this needs to be disabled, set the environmental variable :envvar:`DJANGO_COLORS` to ``nocolor``.","삶의 질 기능은 터미널에 (흑백이 아닌) 컬러 출력을 추가합니다. 최신 터미널에서는 CMD와 PowerShell 모두에서 작동합니다. 비활성화해야 하는 경우, 환경 변수 :envvar:`DJANGO_COLORS`를 ``nocolor``로 설정하십시오."
"On older Windows versions, or legacy terminals, colorama_ must be installed to enable syntax coloring::",이전 Windows 버전 또는 레거시 터미널에서 구문 색상 표시를 활성화하려면 colorama_를 설치해야 합니다::
See :ref:`syntax-coloring` for more information on color settings.,색상 설정에 대한 자세한 내용은 :ref:`syntax-coloring`을 참조하세요.
"In general, Django assumes that ``UTF-8`` encoding is used for I/O. This may cause problems if your system is set to use a different encoding. Recent versions of Python allow setting the :envvar:`PYTHONUTF8` environment variable in order to force a ``UTF-8`` encoding. Windows 10 also provides a system-wide setting by checking ``Use Unicode UTF-8 for worldwide language support`` in :menuselection:`Language --> Administrative Language Settings --> Change system locale` in system settings.","일반적으로, Django는 ``UTF-8`` 인코딩이 I/O에 사용된다고 가정합니다. 시스템이 다른 인코딩을 사용하도록 설정된 경우 이로 인해 문제가 발생할 수 있습니다. 최신 버전의 Python에서는 ``UTF-8`` 인코딩을 강제하기 위해 :envvar:`PYTHONUTF8` 환경 변수를 설정할 수 있습니다. Windows 10은 또한 시스템 설정의 :menuselection:`언어 --> 관리 언어 설정 --> 시스템 로케일 변경`에서 ``세계 언어 지원에 유니코드 UTF-8 사용``을 선택하여 시스템 전체 설정을 제공합니다."
How to create database migrations,데이터베이스 마이그레이션을 생성하는 방법
``myapp/dbrouters.py``,``myapp/dbrouters.py``
``0006_remove_uuid_null.py``,``0006_remove_uuid_null.py``
``0004_add_uuid_field.py``,``0004_add_uuid_field.py``
``0005_populate_uuid_values.py``,``0005_populate_uuid_values.py``
``myapp/migrations/0124_move_old_app_to_new_app.py``,``myapp/migrations/0124_move_old_app_to_new_app.py``
"If you change a :class:`~django.db.models.ManyToManyField` to use a ``through`` model, the default migration will delete the existing table and create a new one, losing the existing relations. To avoid this, you can use :class:`.SeparateDatabaseAndState` to rename the existing table to the new table name while telling the migration autodetector that the new model has been created. You can check the existing table name through :djadmin:`sqlmigrate` or :djadmin:`dbshell`. You can check the new table name with the through model's ``_meta.db_table`` property. Your new ``through`` model should use the same names for the ``ForeignKey``\s as Django did. Also if it needs any extra fields, they should be added in operations after :class:`.SeparateDatabaseAndState`.",":class:~django.db.models.ManyToManyField를 ``through`` 모델을 사용하도록 변경하면, 기본 마이그레이션이 기존 테이블을 삭제하고 새 테이블을 생성하여 기존 관계를 잃게 됩니다. 이를 방지하려면, 마이그레이션 자동 감지기에 새 모델이 생성되었음을 알리면서 기존 테이블의 이름을 새 테이블 이름으로 변경하기 위해 :class:`.SeparateDatabaseAndState`를 사용할 수 있습니다. 기존 테이블 이름은 :djadmin:`sqlmigrate` 또는 :djadmin:`dbshell`을 통해 확인할 수 있습니다. 새 테이블 이름은 모델의 ``_meta.db_table`` 속성을 통해 확인할 수 있습니다. 새로운 ``through`` 모델은 Django와 같은 ``ForeignKey``\s 이름을 사용해야 합니다. 또한 추가 필드가 필요한 경우 작업에서 :class:`.SeparateDatabaseAndState` 이후에 추가해야 합니다."
